{"version":3,"file":"solver.js","sources":["../../../../../../node_modules/focus-lock/dist/es2015/solver.js"],"sourcesContent":["import { correctNodes } from './utils/correctFocus';\nimport { pickFocusable } from './utils/firstFocus';\nimport { isGuard } from './utils/is';\nexport var NEW_FOCUS = 'NEW_FOCUS';\n/**\n * Main solver for the \"find next focus\" question\n * @param innerNodes\n * @param outerNodes\n * @param activeElement\n * @param lastNode\n * @returns {number|string|undefined|*}\n */\nexport var newFocus = function (innerNodes, outerNodes, activeElement, lastNode) {\n    var cnt = innerNodes.length;\n    var firstFocus = innerNodes[0];\n    var lastFocus = innerNodes[cnt - 1];\n    var isOnGuard = isGuard(activeElement);\n    // focus is inside\n    if (activeElement && innerNodes.indexOf(activeElement) >= 0) {\n        return undefined;\n    }\n    var activeIndex = activeElement !== undefined ? outerNodes.indexOf(activeElement) : -1;\n    var lastIndex = lastNode ? outerNodes.indexOf(lastNode) : activeIndex;\n    var lastNodeInside = lastNode ? innerNodes.indexOf(lastNode) : -1;\n    var indexDiff = activeIndex - lastIndex;\n    var firstNodeIndex = outerNodes.indexOf(firstFocus);\n    var lastNodeIndex = outerNodes.indexOf(lastFocus);\n    var correctedNodes = correctNodes(outerNodes);\n    var correctedIndex = activeElement !== undefined ? correctedNodes.indexOf(activeElement) : -1;\n    var correctedIndexDiff = correctedIndex - (lastNode ? correctedNodes.indexOf(lastNode) : activeIndex);\n    var returnFirstNode = pickFocusable(innerNodes, 0);\n    var returnLastNode = pickFocusable(innerNodes, cnt - 1);\n    // new focus\n    if (activeIndex === -1 || lastNodeInside === -1) {\n        return NEW_FOCUS;\n    }\n    // old focus\n    if (!indexDiff && lastNodeInside >= 0) {\n        return lastNodeInside;\n    }\n    // first element\n    if (activeIndex <= firstNodeIndex && isOnGuard && Math.abs(indexDiff) > 1) {\n        return returnLastNode;\n    }\n    // last element\n    if (activeIndex >= lastNodeIndex && isOnGuard && Math.abs(indexDiff) > 1) {\n        return returnFirstNode;\n    }\n    // jump out, but not on the guard\n    if (indexDiff && Math.abs(correctedIndexDiff) > 1) {\n        return lastNodeInside;\n    }\n    // focus above lock\n    if (activeIndex <= firstNodeIndex) {\n        return returnLastNode;\n    }\n    // focus below lock\n    if (activeIndex > lastNodeIndex) {\n        return returnFirstNode;\n    }\n    // index is inside tab order, but outside Lock\n    if (indexDiff) {\n        if (Math.abs(indexDiff) > 1) {\n            return lastNodeInside;\n        }\n        return (cnt + lastNodeInside + indexDiff) % cnt;\n    }\n    // do nothing\n    return undefined;\n};\n"],"names":["innerNodes","outerNodes","activeElement","lastNode","cnt","length","firstFocus","lastFocus","isOnGuard","isGuard","indexOf","activeIndex","undefined","lastIndex","lastNodeInside","indexDiff","firstNodeIndex","lastNodeIndex","correctedNodes","correctNodes","correctedIndexDiff","returnFirstNode","pickFocusable","returnLastNode","Math","abs"],"mappings":"6LAGuB,6BASD,SAAUA,EAAYC,EAAYC,EAAeC,GACnE,IAAIC,EAAMJ,EAAWK,OACjBC,EAAaN,EAAW,GACxBO,EAAYP,EAAWI,EAAM,GAC7BI,EAAYC,UAAQP,GAExB,KAAIA,GAAiBF,EAAWU,QAAQR,IAAkB,GAA1D,CAGA,IAAIS,OAAgCC,IAAlBV,EAA8BD,EAAWS,QAAQR,IAAkB,EACjFW,EAAYV,EAAWF,EAAWS,QAAQP,GAAYQ,EACtDG,EAAiBX,EAAWH,EAAWU,QAAQP,IAAa,EAC5DY,EAAYJ,EAAcE,EAC1BG,EAAiBf,EAAWS,QAAQJ,GACpCW,EAAgBhB,EAAWS,QAAQH,GACnCW,EAAiBC,eAAalB,GAE9BmB,QADmCR,IAAlBV,EAA8BgB,EAAeR,QAAQR,IAAkB,IACjDC,EAAWe,EAAeR,QAAQP,GAAYQ,GACrFU,EAAkBC,EAAAA,cAActB,EAAY,GAC5CuB,EAAiBD,EAAaA,cAACtB,EAAYI,EAAM,GAErD,OAAqB,IAAjBO,IAA0C,IAApBG,EA9BP,aAkCdC,GAAaD,GAAkB,EACzBA,EAGPH,GAAeK,GAAkBR,GAAagB,KAAKC,IAAIV,GAAa,EAC7DQ,EAGPZ,GAAeM,GAAiBT,GAAagB,KAAKC,IAAIV,GAAa,EAC5DM,EAGPN,GAAaS,KAAKC,IAAIL,GAAsB,EACrCN,EAGPH,GAAeK,EACRO,EAGPZ,EAAcM,EACPI,EAGPN,EACIS,KAAKC,IAAIV,GAAa,EACfD,GAEHV,EAAMU,EAAiBC,GAAaX,OAJhD,CAzCC,CAiDL"}