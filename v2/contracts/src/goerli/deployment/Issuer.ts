// !!! DO NOT EDIT !!! Automatically generated file

export const name = 'Issuer';
export const address = '0x903c9FA8767F459e077062219E368D992F388d2d';
export const source = 'Issuer';
export const abi = [
  'constructor(address _owner, address _resolver)',
  'event CacheUpdated(bytes32 name, address destination)',
  'event OwnerChanged(address oldOwner, address newOwner)',
  'event OwnerNominated(address newOwner)',
  'event SynthAdded(bytes32 currencyKey, address synth)',
  'event SynthRemoved(bytes32 currencyKey, address synth)',
  'function CONTRACT_NAME() view returns (bytes32)',
  'function acceptOwnership()',
  'function addSynth(address synth)',
  'function addSynths(address[] synthsToAdd)',
  'function allNetworksDebtInfo() view returns (uint256 debt, uint256 sharesSupply, bool isStale)',
  'function anySynthOrSNXRateIsInvalid() view returns (bool anyRateInvalid)',
  'function availableCurrencyKeys() view returns (bytes32[])',
  'function availableSynthCount() view returns (uint256)',
  'function availableSynths(uint256) view returns (address)',
  'function burnForRedemption(address deprecatedSynthProxy, address account, uint256 balance)',
  'function burnSynths(address from, uint256 amount)',
  'function burnSynthsOnBehalf(address burnForAddress, address from, uint256 amount)',
  'function burnSynthsToTarget(address from)',
  'function burnSynthsToTargetOnBehalf(address burnForAddress, address from)',
  'function burnSynthsWithoutDebt(bytes32 currencyKey, address from, uint256 amount) returns (bool rateInvalid)',
  'function canBurnSynths(address account) view returns (bool)',
  'function collateral(address account) view returns (uint256)',
  'function collateralisationRatio(address _issuer) view returns (uint256 cratio)',
  'function collateralisationRatioAndAnyRatesInvalid(address _issuer) view returns (uint256 cratio, bool anyRateIsInvalid)',
  'function debtBalanceOf(address _issuer, bytes32 currencyKey) view returns (uint256 debtBalance)',
  'function getSynths(bytes32[] currencyKeys) view returns (address[])',
  'function isResolverCached() view returns (bool)',
  'function issuanceRatio() view returns (uint256)',
  'function issueMaxSynths(address from)',
  'function issueMaxSynthsOnBehalf(address issueForAddress, address from)',
  'function issueSynths(address from, uint256 amount)',
  'function issueSynthsOnBehalf(address issueForAddress, address from, uint256 amount)',
  'function issueSynthsWithoutDebt(bytes32 currencyKey, address to, uint256 amount) returns (bool rateInvalid)',
  'function lastIssueEvent(address account) view returns (uint256)',
  'function liquidateAccount(address account, bool isSelfLiquidation) returns (uint256 totalRedeemed, uint256 debtRemoved, uint256 escrowToLiquidate)',
  'function liquidationAmounts(address account, bool isSelfLiquidation) view returns (uint256 totalRedeemed, uint256 debtToRemove, uint256 escrowToLiquidate, uint256 initialDebtBalance)',
  'function maxIssuableSynths(address _issuer) view returns (uint256)',
  'function minimumStakeTime() view returns (uint256)',
  'function modifyDebtSharesForMigration(address account, uint256 amount)',
  'function nominateNewOwner(address _owner)',
  'function nominatedOwner() view returns (address)',
  'function owner() view returns (address)',
  'function rebuildCache()',
  'function remainingIssuableSynths(address _issuer) view returns (uint256 maxIssuable, uint256 alreadyIssued, uint256 totalSystemDebt)',
  'function removeSynth(bytes32 currencyKey)',
  'function removeSynths(bytes32[] currencyKeys)',
  'function resolver() view returns (address)',
  'function resolverAddressesRequired() view returns (bytes32[] addresses)',
  'function setCurrentPeriodId(uint128 periodId)',
  'function synths(bytes32) view returns (address)',
  'function synthsByAddress(address) view returns (bytes32)',
  'function totalIssuedSynths(bytes32 currencyKey, bool excludeOtherCollateral) view returns (uint256 totalIssued)',
  'function transferableSynthetixAndAnyRateIsInvalid(address account, uint256 balance) view returns (uint256 transferable, bool anyRateIsInvalid)',
  'function upgradeCollateralShort(address short, uint256 amount)',
];
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from 'ethers';
import type { FunctionFragment, Result, EventFragment } from '@ethersproject/abi';
import type { Listener, Provider } from '@ethersproject/providers';
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from './common';

export interface IssuerInterface extends utils.Interface {
  functions: {
    'CONTRACT_NAME()': FunctionFragment;
    'acceptOwnership()': FunctionFragment;
    'addSynth(address)': FunctionFragment;
    'addSynths(address[])': FunctionFragment;
    'allNetworksDebtInfo()': FunctionFragment;
    'anySynthOrSNXRateIsInvalid()': FunctionFragment;
    'availableCurrencyKeys()': FunctionFragment;
    'availableSynthCount()': FunctionFragment;
    'availableSynths(uint256)': FunctionFragment;
    'burnForRedemption(address,address,uint256)': FunctionFragment;
    'burnSynths(address,uint256)': FunctionFragment;
    'burnSynthsOnBehalf(address,address,uint256)': FunctionFragment;
    'burnSynthsToTarget(address)': FunctionFragment;
    'burnSynthsToTargetOnBehalf(address,address)': FunctionFragment;
    'burnSynthsWithoutDebt(bytes32,address,uint256)': FunctionFragment;
    'canBurnSynths(address)': FunctionFragment;
    'collateral(address)': FunctionFragment;
    'collateralisationRatio(address)': FunctionFragment;
    'collateralisationRatioAndAnyRatesInvalid(address)': FunctionFragment;
    'debtBalanceOf(address,bytes32)': FunctionFragment;
    'getSynths(bytes32[])': FunctionFragment;
    'isResolverCached()': FunctionFragment;
    'issuanceRatio()': FunctionFragment;
    'issueMaxSynths(address)': FunctionFragment;
    'issueMaxSynthsOnBehalf(address,address)': FunctionFragment;
    'issueSynths(address,uint256)': FunctionFragment;
    'issueSynthsOnBehalf(address,address,uint256)': FunctionFragment;
    'issueSynthsWithoutDebt(bytes32,address,uint256)': FunctionFragment;
    'lastIssueEvent(address)': FunctionFragment;
    'liquidateAccount(address,bool)': FunctionFragment;
    'liquidationAmounts(address,bool)': FunctionFragment;
    'maxIssuableSynths(address)': FunctionFragment;
    'minimumStakeTime()': FunctionFragment;
    'modifyDebtSharesForMigration(address,uint256)': FunctionFragment;
    'nominateNewOwner(address)': FunctionFragment;
    'nominatedOwner()': FunctionFragment;
    'owner()': FunctionFragment;
    'rebuildCache()': FunctionFragment;
    'remainingIssuableSynths(address)': FunctionFragment;
    'removeSynth(bytes32)': FunctionFragment;
    'removeSynths(bytes32[])': FunctionFragment;
    'resolver()': FunctionFragment;
    'resolverAddressesRequired()': FunctionFragment;
    'setCurrentPeriodId(uint128)': FunctionFragment;
    'synths(bytes32)': FunctionFragment;
    'synthsByAddress(address)': FunctionFragment;
    'totalIssuedSynths(bytes32,bool)': FunctionFragment;
    'transferableSynthetixAndAnyRateIsInvalid(address,uint256)': FunctionFragment;
    'upgradeCollateralShort(address,uint256)': FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | 'CONTRACT_NAME'
      | 'acceptOwnership'
      | 'addSynth'
      | 'addSynths'
      | 'allNetworksDebtInfo'
      | 'anySynthOrSNXRateIsInvalid'
      | 'availableCurrencyKeys'
      | 'availableSynthCount'
      | 'availableSynths'
      | 'burnForRedemption'
      | 'burnSynths'
      | 'burnSynthsOnBehalf'
      | 'burnSynthsToTarget'
      | 'burnSynthsToTargetOnBehalf'
      | 'burnSynthsWithoutDebt'
      | 'canBurnSynths'
      | 'collateral'
      | 'collateralisationRatio'
      | 'collateralisationRatioAndAnyRatesInvalid'
      | 'debtBalanceOf'
      | 'getSynths'
      | 'isResolverCached'
      | 'issuanceRatio'
      | 'issueMaxSynths'
      | 'issueMaxSynthsOnBehalf'
      | 'issueSynths'
      | 'issueSynthsOnBehalf'
      | 'issueSynthsWithoutDebt'
      | 'lastIssueEvent'
      | 'liquidateAccount'
      | 'liquidationAmounts'
      | 'maxIssuableSynths'
      | 'minimumStakeTime'
      | 'modifyDebtSharesForMigration'
      | 'nominateNewOwner'
      | 'nominatedOwner'
      | 'owner'
      | 'rebuildCache'
      | 'remainingIssuableSynths'
      | 'removeSynth'
      | 'removeSynths'
      | 'resolver'
      | 'resolverAddressesRequired'
      | 'setCurrentPeriodId'
      | 'synths'
      | 'synthsByAddress'
      | 'totalIssuedSynths'
      | 'transferableSynthetixAndAnyRateIsInvalid'
      | 'upgradeCollateralShort'
  ): FunctionFragment;

  encodeFunctionData(functionFragment: 'CONTRACT_NAME', values?: undefined): string;
  encodeFunctionData(functionFragment: 'acceptOwnership', values?: undefined): string;
  encodeFunctionData(functionFragment: 'addSynth', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'addSynths', values: [PromiseOrValue<string>[]]): string;
  encodeFunctionData(functionFragment: 'allNetworksDebtInfo', values?: undefined): string;
  encodeFunctionData(functionFragment: 'anySynthOrSNXRateIsInvalid', values?: undefined): string;
  encodeFunctionData(functionFragment: 'availableCurrencyKeys', values?: undefined): string;
  encodeFunctionData(functionFragment: 'availableSynthCount', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'availableSynths',
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: 'burnForRedemption',
    values: [PromiseOrValue<string>, PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: 'burnSynths',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: 'burnSynthsOnBehalf',
    values: [PromiseOrValue<string>, PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: 'burnSynthsToTarget',
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: 'burnSynthsToTargetOnBehalf',
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: 'burnSynthsWithoutDebt',
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(functionFragment: 'canBurnSynths', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'collateral', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'collateralisationRatio',
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: 'collateralisationRatioAndAnyRatesInvalid',
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: 'debtBalanceOf',
    values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(functionFragment: 'getSynths', values: [PromiseOrValue<BytesLike>[]]): string;
  encodeFunctionData(functionFragment: 'isResolverCached', values?: undefined): string;
  encodeFunctionData(functionFragment: 'issuanceRatio', values?: undefined): string;
  encodeFunctionData(functionFragment: 'issueMaxSynths', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'issueMaxSynthsOnBehalf',
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: 'issueSynths',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: 'issueSynthsOnBehalf',
    values: [PromiseOrValue<string>, PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: 'issueSynthsWithoutDebt',
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(functionFragment: 'lastIssueEvent', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'liquidateAccount',
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: 'liquidationAmounts',
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: 'maxIssuableSynths',
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(functionFragment: 'minimumStakeTime', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'modifyDebtSharesForMigration',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: 'nominateNewOwner',
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(functionFragment: 'nominatedOwner', values?: undefined): string;
  encodeFunctionData(functionFragment: 'owner', values?: undefined): string;
  encodeFunctionData(functionFragment: 'rebuildCache', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'remainingIssuableSynths',
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(functionFragment: 'removeSynth', values: [PromiseOrValue<BytesLike>]): string;
  encodeFunctionData(
    functionFragment: 'removeSynths',
    values: [PromiseOrValue<BytesLike>[]]
  ): string;
  encodeFunctionData(functionFragment: 'resolver', values?: undefined): string;
  encodeFunctionData(functionFragment: 'resolverAddressesRequired', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'setCurrentPeriodId',
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(functionFragment: 'synths', values: [PromiseOrValue<BytesLike>]): string;
  encodeFunctionData(functionFragment: 'synthsByAddress', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'totalIssuedSynths',
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: 'transferableSynthetixAndAnyRateIsInvalid',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: 'upgradeCollateralShort',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;

  decodeFunctionResult(functionFragment: 'CONTRACT_NAME', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'acceptOwnership', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'addSynth', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'addSynths', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'allNetworksDebtInfo', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'anySynthOrSNXRateIsInvalid', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'availableCurrencyKeys', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'availableSynthCount', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'availableSynths', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'burnForRedemption', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'burnSynths', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'burnSynthsOnBehalf', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'burnSynthsToTarget', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'burnSynthsToTargetOnBehalf', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'burnSynthsWithoutDebt', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'canBurnSynths', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'collateral', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'collateralisationRatio', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'collateralisationRatioAndAnyRatesInvalid',
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: 'debtBalanceOf', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getSynths', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'isResolverCached', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'issuanceRatio', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'issueMaxSynths', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'issueMaxSynthsOnBehalf', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'issueSynths', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'issueSynthsOnBehalf', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'issueSynthsWithoutDebt', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'lastIssueEvent', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'liquidateAccount', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'liquidationAmounts', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'maxIssuableSynths', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'minimumStakeTime', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'modifyDebtSharesForMigration', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'nominateNewOwner', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'nominatedOwner', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'owner', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'rebuildCache', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'remainingIssuableSynths', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'removeSynth', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'removeSynths', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'resolver', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'resolverAddressesRequired', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setCurrentPeriodId', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'synths', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'synthsByAddress', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'totalIssuedSynths', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'transferableSynthetixAndAnyRateIsInvalid',
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: 'upgradeCollateralShort', data: BytesLike): Result;

  events: {
    'CacheUpdated(bytes32,address)': EventFragment;
    'OwnerChanged(address,address)': EventFragment;
    'OwnerNominated(address)': EventFragment;
    'SynthAdded(bytes32,address)': EventFragment;
    'SynthRemoved(bytes32,address)': EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: 'CacheUpdated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'OwnerChanged'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'OwnerNominated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'SynthAdded'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'SynthRemoved'): EventFragment;
}

export interface CacheUpdatedEventObject {
  name: string;
  destination: string;
}
export type CacheUpdatedEvent = TypedEvent<[string, string], CacheUpdatedEventObject>;

export type CacheUpdatedEventFilter = TypedEventFilter<CacheUpdatedEvent>;

export interface OwnerChangedEventObject {
  oldOwner: string;
  newOwner: string;
}
export type OwnerChangedEvent = TypedEvent<[string, string], OwnerChangedEventObject>;

export type OwnerChangedEventFilter = TypedEventFilter<OwnerChangedEvent>;

export interface OwnerNominatedEventObject {
  newOwner: string;
}
export type OwnerNominatedEvent = TypedEvent<[string], OwnerNominatedEventObject>;

export type OwnerNominatedEventFilter = TypedEventFilter<OwnerNominatedEvent>;

export interface SynthAddedEventObject {
  currencyKey: string;
  synth: string;
}
export type SynthAddedEvent = TypedEvent<[string, string], SynthAddedEventObject>;

export type SynthAddedEventFilter = TypedEventFilter<SynthAddedEvent>;

export interface SynthRemovedEventObject {
  currencyKey: string;
  synth: string;
}
export type SynthRemovedEvent = TypedEvent<[string, string], SynthRemovedEventObject>;

export type SynthRemovedEventFilter = TypedEventFilter<SynthRemovedEvent>;

export interface Issuer extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: IssuerInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    CONTRACT_NAME(overrides?: CallOverrides): Promise<[string]>;

    acceptOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    addSynth(
      synth: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    addSynths(
      synthsToAdd: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    allNetworksDebtInfo(overrides?: CallOverrides): Promise<
      [BigNumber, BigNumber, boolean] & {
        debt: BigNumber;
        sharesSupply: BigNumber;
        isStale: boolean;
      }
    >;

    anySynthOrSNXRateIsInvalid(
      overrides?: CallOverrides
    ): Promise<[boolean] & { anyRateInvalid: boolean }>;

    availableCurrencyKeys(overrides?: CallOverrides): Promise<[string[]]>;

    availableSynthCount(overrides?: CallOverrides): Promise<[BigNumber]>;

    availableSynths(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    burnForRedemption(
      deprecatedSynthProxy: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      balance: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    burnSynths(
      from: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    burnSynthsOnBehalf(
      burnForAddress: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    burnSynthsToTarget(
      from: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    burnSynthsToTargetOnBehalf(
      burnForAddress: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    burnSynthsWithoutDebt(
      currencyKey: PromiseOrValue<BytesLike>,
      from: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    canBurnSynths(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;

    collateral(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber]>;

    collateralisationRatio(
      _issuer: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { cratio: BigNumber }>;

    collateralisationRatioAndAnyRatesInvalid(
      _issuer: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber, boolean] & { cratio: BigNumber; anyRateIsInvalid: boolean }>;

    debtBalanceOf(
      _issuer: PromiseOrValue<string>,
      currencyKey: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { debtBalance: BigNumber }>;

    getSynths(
      currencyKeys: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides
    ): Promise<[string[]]>;

    isResolverCached(overrides?: CallOverrides): Promise<[boolean]>;

    issuanceRatio(overrides?: CallOverrides): Promise<[BigNumber]>;

    issueMaxSynths(
      from: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    issueMaxSynthsOnBehalf(
      issueForAddress: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    issueSynths(
      from: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    issueSynthsOnBehalf(
      issueForAddress: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    issueSynthsWithoutDebt(
      currencyKey: PromiseOrValue<BytesLike>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    lastIssueEvent(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    liquidateAccount(
      account: PromiseOrValue<string>,
      isSelfLiquidation: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    liquidationAmounts(
      account: PromiseOrValue<string>,
      isSelfLiquidation: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber] & {
        totalRedeemed: BigNumber;
        debtToRemove: BigNumber;
        escrowToLiquidate: BigNumber;
        initialDebtBalance: BigNumber;
      }
    >;

    maxIssuableSynths(
      _issuer: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    minimumStakeTime(overrides?: CallOverrides): Promise<[BigNumber]>;

    modifyDebtSharesForMigration(
      account: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    nominateNewOwner(
      _owner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    nominatedOwner(overrides?: CallOverrides): Promise<[string]>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    rebuildCache(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    remainingIssuableSynths(
      _issuer: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        maxIssuable: BigNumber;
        alreadyIssued: BigNumber;
        totalSystemDebt: BigNumber;
      }
    >;

    removeSynth(
      currencyKey: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    removeSynths(
      currencyKeys: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    resolver(overrides?: CallOverrides): Promise<[string]>;

    resolverAddressesRequired(
      overrides?: CallOverrides
    ): Promise<[string[]] & { addresses: string[] }>;

    setCurrentPeriodId(
      periodId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    synths(arg0: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[string]>;

    synthsByAddress(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[string]>;

    totalIssuedSynths(
      currencyKey: PromiseOrValue<BytesLike>,
      excludeOtherCollateral: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { totalIssued: BigNumber }>;

    transferableSynthetixAndAnyRateIsInvalid(
      account: PromiseOrValue<string>,
      balance: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber, boolean] & { transferable: BigNumber; anyRateIsInvalid: boolean }>;

    upgradeCollateralShort(
      short: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;
  };

  CONTRACT_NAME(overrides?: CallOverrides): Promise<string>;

  acceptOwnership(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  addSynth(
    synth: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  addSynths(
    synthsToAdd: PromiseOrValue<string>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  allNetworksDebtInfo(
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, boolean] & { debt: BigNumber; sharesSupply: BigNumber; isStale: boolean }
  >;

  anySynthOrSNXRateIsInvalid(overrides?: CallOverrides): Promise<boolean>;

  availableCurrencyKeys(overrides?: CallOverrides): Promise<string[]>;

  availableSynthCount(overrides?: CallOverrides): Promise<BigNumber>;

  availableSynths(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<string>;

  burnForRedemption(
    deprecatedSynthProxy: PromiseOrValue<string>,
    account: PromiseOrValue<string>,
    balance: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  burnSynths(
    from: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  burnSynthsOnBehalf(
    burnForAddress: PromiseOrValue<string>,
    from: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  burnSynthsToTarget(
    from: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  burnSynthsToTargetOnBehalf(
    burnForAddress: PromiseOrValue<string>,
    from: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  burnSynthsWithoutDebt(
    currencyKey: PromiseOrValue<BytesLike>,
    from: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  canBurnSynths(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

  collateral(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

  collateralisationRatio(
    _issuer: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  collateralisationRatioAndAnyRatesInvalid(
    _issuer: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<[BigNumber, boolean] & { cratio: BigNumber; anyRateIsInvalid: boolean }>;

  debtBalanceOf(
    _issuer: PromiseOrValue<string>,
    currencyKey: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getSynths(
    currencyKeys: PromiseOrValue<BytesLike>[],
    overrides?: CallOverrides
  ): Promise<string[]>;

  isResolverCached(overrides?: CallOverrides): Promise<boolean>;

  issuanceRatio(overrides?: CallOverrides): Promise<BigNumber>;

  issueMaxSynths(
    from: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  issueMaxSynthsOnBehalf(
    issueForAddress: PromiseOrValue<string>,
    from: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  issueSynths(
    from: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  issueSynthsOnBehalf(
    issueForAddress: PromiseOrValue<string>,
    from: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  issueSynthsWithoutDebt(
    currencyKey: PromiseOrValue<BytesLike>,
    to: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  lastIssueEvent(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

  liquidateAccount(
    account: PromiseOrValue<string>,
    isSelfLiquidation: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  liquidationAmounts(
    account: PromiseOrValue<string>,
    isSelfLiquidation: PromiseOrValue<boolean>,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, BigNumber, BigNumber] & {
      totalRedeemed: BigNumber;
      debtToRemove: BigNumber;
      escrowToLiquidate: BigNumber;
      initialDebtBalance: BigNumber;
    }
  >;

  maxIssuableSynths(_issuer: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

  minimumStakeTime(overrides?: CallOverrides): Promise<BigNumber>;

  modifyDebtSharesForMigration(
    account: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  nominateNewOwner(
    _owner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  nominatedOwner(overrides?: CallOverrides): Promise<string>;

  owner(overrides?: CallOverrides): Promise<string>;

  rebuildCache(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  remainingIssuableSynths(
    _issuer: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, BigNumber] & {
      maxIssuable: BigNumber;
      alreadyIssued: BigNumber;
      totalSystemDebt: BigNumber;
    }
  >;

  removeSynth(
    currencyKey: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  removeSynths(
    currencyKeys: PromiseOrValue<BytesLike>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  resolver(overrides?: CallOverrides): Promise<string>;

  resolverAddressesRequired(overrides?: CallOverrides): Promise<string[]>;

  setCurrentPeriodId(
    periodId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  synths(arg0: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;

  synthsByAddress(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string>;

  totalIssuedSynths(
    currencyKey: PromiseOrValue<BytesLike>,
    excludeOtherCollateral: PromiseOrValue<boolean>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  transferableSynthetixAndAnyRateIsInvalid(
    account: PromiseOrValue<string>,
    balance: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<[BigNumber, boolean] & { transferable: BigNumber; anyRateIsInvalid: boolean }>;

  upgradeCollateralShort(
    short: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    CONTRACT_NAME(overrides?: CallOverrides): Promise<string>;

    acceptOwnership(overrides?: CallOverrides): Promise<void>;

    addSynth(synth: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    addSynths(synthsToAdd: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<void>;

    allNetworksDebtInfo(overrides?: CallOverrides): Promise<
      [BigNumber, BigNumber, boolean] & {
        debt: BigNumber;
        sharesSupply: BigNumber;
        isStale: boolean;
      }
    >;

    anySynthOrSNXRateIsInvalid(overrides?: CallOverrides): Promise<boolean>;

    availableCurrencyKeys(overrides?: CallOverrides): Promise<string[]>;

    availableSynthCount(overrides?: CallOverrides): Promise<BigNumber>;

    availableSynths(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<string>;

    burnForRedemption(
      deprecatedSynthProxy: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      balance: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    burnSynths(
      from: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    burnSynthsOnBehalf(
      burnForAddress: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    burnSynthsToTarget(from: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    burnSynthsToTargetOnBehalf(
      burnForAddress: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    burnSynthsWithoutDebt(
      currencyKey: PromiseOrValue<BytesLike>,
      from: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    canBurnSynths(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

    collateral(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    collateralisationRatio(
      _issuer: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    collateralisationRatioAndAnyRatesInvalid(
      _issuer: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber, boolean] & { cratio: BigNumber; anyRateIsInvalid: boolean }>;

    debtBalanceOf(
      _issuer: PromiseOrValue<string>,
      currencyKey: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getSynths(
      currencyKeys: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides
    ): Promise<string[]>;

    isResolverCached(overrides?: CallOverrides): Promise<boolean>;

    issuanceRatio(overrides?: CallOverrides): Promise<BigNumber>;

    issueMaxSynths(from: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    issueMaxSynthsOnBehalf(
      issueForAddress: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    issueSynths(
      from: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    issueSynthsOnBehalf(
      issueForAddress: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    issueSynthsWithoutDebt(
      currencyKey: PromiseOrValue<BytesLike>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    lastIssueEvent(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    liquidateAccount(
      account: PromiseOrValue<string>,
      isSelfLiquidation: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        totalRedeemed: BigNumber;
        debtRemoved: BigNumber;
        escrowToLiquidate: BigNumber;
      }
    >;

    liquidationAmounts(
      account: PromiseOrValue<string>,
      isSelfLiquidation: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber] & {
        totalRedeemed: BigNumber;
        debtToRemove: BigNumber;
        escrowToLiquidate: BigNumber;
        initialDebtBalance: BigNumber;
      }
    >;

    maxIssuableSynths(
      _issuer: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    minimumStakeTime(overrides?: CallOverrides): Promise<BigNumber>;

    modifyDebtSharesForMigration(
      account: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    nominateNewOwner(_owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    nominatedOwner(overrides?: CallOverrides): Promise<string>;

    owner(overrides?: CallOverrides): Promise<string>;

    rebuildCache(overrides?: CallOverrides): Promise<void>;

    remainingIssuableSynths(
      _issuer: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        maxIssuable: BigNumber;
        alreadyIssued: BigNumber;
        totalSystemDebt: BigNumber;
      }
    >;

    removeSynth(currencyKey: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<void>;

    removeSynths(
      currencyKeys: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides
    ): Promise<void>;

    resolver(overrides?: CallOverrides): Promise<string>;

    resolverAddressesRequired(overrides?: CallOverrides): Promise<string[]>;

    setCurrentPeriodId(
      periodId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    synths(arg0: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;

    synthsByAddress(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string>;

    totalIssuedSynths(
      currencyKey: PromiseOrValue<BytesLike>,
      excludeOtherCollateral: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    transferableSynthetixAndAnyRateIsInvalid(
      account: PromiseOrValue<string>,
      balance: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber, boolean] & { transferable: BigNumber; anyRateIsInvalid: boolean }>;

    upgradeCollateralShort(
      short: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    'CacheUpdated(bytes32,address)'(name?: null, destination?: null): CacheUpdatedEventFilter;
    CacheUpdated(name?: null, destination?: null): CacheUpdatedEventFilter;

    'OwnerChanged(address,address)'(oldOwner?: null, newOwner?: null): OwnerChangedEventFilter;
    OwnerChanged(oldOwner?: null, newOwner?: null): OwnerChangedEventFilter;

    'OwnerNominated(address)'(newOwner?: null): OwnerNominatedEventFilter;
    OwnerNominated(newOwner?: null): OwnerNominatedEventFilter;

    'SynthAdded(bytes32,address)'(currencyKey?: null, synth?: null): SynthAddedEventFilter;
    SynthAdded(currencyKey?: null, synth?: null): SynthAddedEventFilter;

    'SynthRemoved(bytes32,address)'(currencyKey?: null, synth?: null): SynthRemovedEventFilter;
    SynthRemoved(currencyKey?: null, synth?: null): SynthRemovedEventFilter;
  };

  estimateGas: {
    CONTRACT_NAME(overrides?: CallOverrides): Promise<BigNumber>;

    acceptOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    addSynth(
      synth: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    addSynths(
      synthsToAdd: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    allNetworksDebtInfo(overrides?: CallOverrides): Promise<BigNumber>;

    anySynthOrSNXRateIsInvalid(overrides?: CallOverrides): Promise<BigNumber>;

    availableCurrencyKeys(overrides?: CallOverrides): Promise<BigNumber>;

    availableSynthCount(overrides?: CallOverrides): Promise<BigNumber>;

    availableSynths(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    burnForRedemption(
      deprecatedSynthProxy: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      balance: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    burnSynths(
      from: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    burnSynthsOnBehalf(
      burnForAddress: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    burnSynthsToTarget(
      from: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    burnSynthsToTargetOnBehalf(
      burnForAddress: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    burnSynthsWithoutDebt(
      currencyKey: PromiseOrValue<BytesLike>,
      from: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    canBurnSynths(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    collateral(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    collateralisationRatio(
      _issuer: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    collateralisationRatioAndAnyRatesInvalid(
      _issuer: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    debtBalanceOf(
      _issuer: PromiseOrValue<string>,
      currencyKey: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getSynths(
      currencyKeys: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isResolverCached(overrides?: CallOverrides): Promise<BigNumber>;

    issuanceRatio(overrides?: CallOverrides): Promise<BigNumber>;

    issueMaxSynths(
      from: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    issueMaxSynthsOnBehalf(
      issueForAddress: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    issueSynths(
      from: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    issueSynthsOnBehalf(
      issueForAddress: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    issueSynthsWithoutDebt(
      currencyKey: PromiseOrValue<BytesLike>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    lastIssueEvent(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    liquidateAccount(
      account: PromiseOrValue<string>,
      isSelfLiquidation: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    liquidationAmounts(
      account: PromiseOrValue<string>,
      isSelfLiquidation: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    maxIssuableSynths(
      _issuer: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    minimumStakeTime(overrides?: CallOverrides): Promise<BigNumber>;

    modifyDebtSharesForMigration(
      account: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    nominateNewOwner(
      _owner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    nominatedOwner(overrides?: CallOverrides): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    rebuildCache(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    remainingIssuableSynths(
      _issuer: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    removeSynth(
      currencyKey: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    removeSynths(
      currencyKeys: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    resolver(overrides?: CallOverrides): Promise<BigNumber>;

    resolverAddressesRequired(overrides?: CallOverrides): Promise<BigNumber>;

    setCurrentPeriodId(
      periodId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    synths(arg0: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber>;

    synthsByAddress(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    totalIssuedSynths(
      currencyKey: PromiseOrValue<BytesLike>,
      excludeOtherCollateral: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    transferableSynthetixAndAnyRateIsInvalid(
      account: PromiseOrValue<string>,
      balance: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    upgradeCollateralShort(
      short: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    CONTRACT_NAME(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    acceptOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    addSynth(
      synth: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    addSynths(
      synthsToAdd: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    allNetworksDebtInfo(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    anySynthOrSNXRateIsInvalid(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    availableCurrencyKeys(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    availableSynthCount(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    availableSynths(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    burnForRedemption(
      deprecatedSynthProxy: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      balance: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    burnSynths(
      from: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    burnSynthsOnBehalf(
      burnForAddress: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    burnSynthsToTarget(
      from: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    burnSynthsToTargetOnBehalf(
      burnForAddress: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    burnSynthsWithoutDebt(
      currencyKey: PromiseOrValue<BytesLike>,
      from: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    canBurnSynths(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    collateral(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    collateralisationRatio(
      _issuer: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    collateralisationRatioAndAnyRatesInvalid(
      _issuer: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    debtBalanceOf(
      _issuer: PromiseOrValue<string>,
      currencyKey: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getSynths(
      currencyKeys: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isResolverCached(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    issuanceRatio(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    issueMaxSynths(
      from: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    issueMaxSynthsOnBehalf(
      issueForAddress: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    issueSynths(
      from: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    issueSynthsOnBehalf(
      issueForAddress: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    issueSynthsWithoutDebt(
      currencyKey: PromiseOrValue<BytesLike>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    lastIssueEvent(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    liquidateAccount(
      account: PromiseOrValue<string>,
      isSelfLiquidation: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    liquidationAmounts(
      account: PromiseOrValue<string>,
      isSelfLiquidation: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    maxIssuableSynths(
      _issuer: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    minimumStakeTime(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    modifyDebtSharesForMigration(
      account: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    nominateNewOwner(
      _owner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    nominatedOwner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    rebuildCache(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    remainingIssuableSynths(
      _issuer: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    removeSynth(
      currencyKey: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    removeSynths(
      currencyKeys: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    resolver(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    resolverAddressesRequired(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    setCurrentPeriodId(
      periodId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    synths(
      arg0: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    synthsByAddress(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    totalIssuedSynths(
      currencyKey: PromiseOrValue<BytesLike>,
      excludeOtherCollateral: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    transferableSynthetixAndAnyRateIsInvalid(
      account: PromiseOrValue<string>,
      balance: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    upgradeCollateralShort(
      short: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;
  };
}
