"""
creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API.
"""
directive @derivedFrom(field: String!) on FIELD_DEFINITION

"""
Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive.
"""
directive @entity on OBJECT

"""
Defined a Subgraph ID for an object type
"""
directive @subgraphId(id: String!) on OBJECT

type AccountFlaggedForLiquidation {
  """
  the address of the staker
  """
  account: Bytes!

  """
  total collateral held by the staker including escrow amount
  """
  collateral: BigDecimal!

  """
  current collateral ratio
  """
  collateralRatio: BigInt!

  """
  liqudation deadline
  """
  deadline: BigInt!

  """
  the deadline plus the staker address
  """
  id: ID!

  """
  snx that is liquidatable
  """
  liquidatableNonEscrowSNX: BigDecimal!
}

input AccountFlaggedForLiquidation_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  account: Bytes
  account_contains: Bytes
  account_gt: Bytes
  account_gte: Bytes
  account_in: [Bytes!]
  account_lt: Bytes
  account_lte: Bytes
  account_not: Bytes
  account_not_contains: Bytes
  account_not_in: [Bytes!]
  and: [AccountFlaggedForLiquidation_filter]
  collateral: BigDecimal
  collateralRatio: BigInt
  collateralRatio_gt: BigInt
  collateralRatio_gte: BigInt
  collateralRatio_in: [BigInt!]
  collateralRatio_lt: BigInt
  collateralRatio_lte: BigInt
  collateralRatio_not: BigInt
  collateralRatio_not_in: [BigInt!]
  collateral_gt: BigDecimal
  collateral_gte: BigDecimal
  collateral_in: [BigDecimal!]
  collateral_lt: BigDecimal
  collateral_lte: BigDecimal
  collateral_not: BigDecimal
  collateral_not_in: [BigDecimal!]
  deadline: BigInt
  deadline_gt: BigInt
  deadline_gte: BigInt
  deadline_in: [BigInt!]
  deadline_lt: BigInt
  deadline_lte: BigInt
  deadline_not: BigInt
  deadline_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  liquidatableNonEscrowSNX: BigDecimal
  liquidatableNonEscrowSNX_gt: BigDecimal
  liquidatableNonEscrowSNX_gte: BigDecimal
  liquidatableNonEscrowSNX_in: [BigDecimal!]
  liquidatableNonEscrowSNX_lt: BigDecimal
  liquidatableNonEscrowSNX_lte: BigDecimal
  liquidatableNonEscrowSNX_not: BigDecimal
  liquidatableNonEscrowSNX_not_in: [BigDecimal!]
  or: [AccountFlaggedForLiquidation_filter]
}

enum AccountFlaggedForLiquidation_orderBy {
  account
  collateral
  collateralRatio
  deadline
  id
  liquidatableNonEscrowSNX
}

type AccountLiquidated {
  """
  the liquidated address
  """
  account: Bytes!

  """
  the amount of sUSD liquidated
  """
  amountLiquidated: BigDecimal!
  id: ID!

  """
  the address liquidating the account
  """
  liquidator: Bytes!

  """
  the amount of SNX redeemed by the liquidator
  """
  snxRedeemed: BigDecimal!

  """
  the time at which the liquidation occurred
  """
  time: BigInt!
}

input AccountLiquidated_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  account: Bytes
  account_contains: Bytes
  account_gt: Bytes
  account_gte: Bytes
  account_in: [Bytes!]
  account_lt: Bytes
  account_lte: Bytes
  account_not: Bytes
  account_not_contains: Bytes
  account_not_in: [Bytes!]
  amountLiquidated: BigDecimal
  amountLiquidated_gt: BigDecimal
  amountLiquidated_gte: BigDecimal
  amountLiquidated_in: [BigDecimal!]
  amountLiquidated_lt: BigDecimal
  amountLiquidated_lte: BigDecimal
  amountLiquidated_not: BigDecimal
  amountLiquidated_not_in: [BigDecimal!]
  and: [AccountLiquidated_filter]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  liquidator: Bytes
  liquidator_contains: Bytes
  liquidator_gt: Bytes
  liquidator_gte: Bytes
  liquidator_in: [Bytes!]
  liquidator_lt: Bytes
  liquidator_lte: Bytes
  liquidator_not: Bytes
  liquidator_not_contains: Bytes
  liquidator_not_in: [Bytes!]
  or: [AccountLiquidated_filter]
  snxRedeemed: BigDecimal
  snxRedeemed_gt: BigDecimal
  snxRedeemed_gte: BigDecimal
  snxRedeemed_in: [BigDecimal!]
  snxRedeemed_lt: BigDecimal
  snxRedeemed_lte: BigDecimal
  snxRedeemed_not: BigDecimal
  snxRedeemed_not_in: [BigDecimal!]
  time: BigInt
  time_gt: BigInt
  time_gte: BigInt
  time_in: [BigInt!]
  time_lt: BigInt
  time_lte: BigInt
  time_not: BigInt
  time_not_in: [BigInt!]
}

enum AccountLiquidated_orderBy {
  account
  amountLiquidated
  id
  liquidator
  snxRedeemed
  time
}

type AccountRemovedFromLiquidation {
  """
  the address of the staker
  """
  account: Bytes!

  """
  the time at which the staker fixed their c-ratio plus the staker address
  """
  id: ID!

  """
  the time at which the staker fixed their c-ratio
  """
  time: BigInt!
}

input AccountRemovedFromLiquidation_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  account: Bytes
  account_contains: Bytes
  account_gt: Bytes
  account_gte: Bytes
  account_in: [Bytes!]
  account_lt: Bytes
  account_lte: Bytes
  account_not: Bytes
  account_not_contains: Bytes
  account_not_in: [Bytes!]
  and: [AccountRemovedFromLiquidation_filter]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [AccountRemovedFromLiquidation_filter]
  time: BigInt
  time_gt: BigInt
  time_gte: BigInt
  time_in: [BigInt!]
  time_lt: BigInt
  time_lte: BigInt
  time_not: BigInt
  time_not_in: [BigInt!]
}

enum AccountRemovedFromLiquidation_orderBy {
  account
  id
  time
}

type ActiveStaker {
  id: ID!
}

input ActiveStaker_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [ActiveStaker_filter]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [ActiveStaker_filter]
}

enum ActiveStaker_orderBy {
  id
}

"""
Tracks this event from the Synthetix.sol contract. (Atomic exchanges also trigger standard SynthExchange events.)
"""
type AtomicSynthExchange {
  account: Exchanger!
  feesInUSD: BigDecimal!
  fromAmount: BigDecimal!
  fromAmountInUSD: BigDecimal!
  fromSynth: Synth
  gasPrice: BigInt!
  id: ID!
  timestamp: BigInt!
  toAddress: Bytes!
  toAmount: BigDecimal!
  toAmountInUSD: BigDecimal!
  toSynth: Synth
}

input AtomicSynthExchange_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  account: String
  account_: Exchanger_filter
  account_contains: String
  account_contains_nocase: String
  account_ends_with: String
  account_ends_with_nocase: String
  account_gt: String
  account_gte: String
  account_in: [String!]
  account_lt: String
  account_lte: String
  account_not: String
  account_not_contains: String
  account_not_contains_nocase: String
  account_not_ends_with: String
  account_not_ends_with_nocase: String
  account_not_in: [String!]
  account_not_starts_with: String
  account_not_starts_with_nocase: String
  account_starts_with: String
  account_starts_with_nocase: String
  and: [AtomicSynthExchange_filter]
  feesInUSD: BigDecimal
  feesInUSD_gt: BigDecimal
  feesInUSD_gte: BigDecimal
  feesInUSD_in: [BigDecimal!]
  feesInUSD_lt: BigDecimal
  feesInUSD_lte: BigDecimal
  feesInUSD_not: BigDecimal
  feesInUSD_not_in: [BigDecimal!]
  fromAmount: BigDecimal
  fromAmountInUSD: BigDecimal
  fromAmountInUSD_gt: BigDecimal
  fromAmountInUSD_gte: BigDecimal
  fromAmountInUSD_in: [BigDecimal!]
  fromAmountInUSD_lt: BigDecimal
  fromAmountInUSD_lte: BigDecimal
  fromAmountInUSD_not: BigDecimal
  fromAmountInUSD_not_in: [BigDecimal!]
  fromAmount_gt: BigDecimal
  fromAmount_gte: BigDecimal
  fromAmount_in: [BigDecimal!]
  fromAmount_lt: BigDecimal
  fromAmount_lte: BigDecimal
  fromAmount_not: BigDecimal
  fromAmount_not_in: [BigDecimal!]
  fromSynth: String
  fromSynth_: Synth_filter
  fromSynth_contains: String
  fromSynth_contains_nocase: String
  fromSynth_ends_with: String
  fromSynth_ends_with_nocase: String
  fromSynth_gt: String
  fromSynth_gte: String
  fromSynth_in: [String!]
  fromSynth_lt: String
  fromSynth_lte: String
  fromSynth_not: String
  fromSynth_not_contains: String
  fromSynth_not_contains_nocase: String
  fromSynth_not_ends_with: String
  fromSynth_not_ends_with_nocase: String
  fromSynth_not_in: [String!]
  fromSynth_not_starts_with: String
  fromSynth_not_starts_with_nocase: String
  fromSynth_starts_with: String
  fromSynth_starts_with_nocase: String
  gasPrice: BigInt
  gasPrice_gt: BigInt
  gasPrice_gte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_lt: BigInt
  gasPrice_lte: BigInt
  gasPrice_not: BigInt
  gasPrice_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [AtomicSynthExchange_filter]
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  toAddress: Bytes
  toAddress_contains: Bytes
  toAddress_gt: Bytes
  toAddress_gte: Bytes
  toAddress_in: [Bytes!]
  toAddress_lt: Bytes
  toAddress_lte: Bytes
  toAddress_not: Bytes
  toAddress_not_contains: Bytes
  toAddress_not_in: [Bytes!]
  toAmount: BigDecimal
  toAmountInUSD: BigDecimal
  toAmountInUSD_gt: BigDecimal
  toAmountInUSD_gte: BigDecimal
  toAmountInUSD_in: [BigDecimal!]
  toAmountInUSD_lt: BigDecimal
  toAmountInUSD_lte: BigDecimal
  toAmountInUSD_not: BigDecimal
  toAmountInUSD_not_in: [BigDecimal!]
  toAmount_gt: BigDecimal
  toAmount_gte: BigDecimal
  toAmount_in: [BigDecimal!]
  toAmount_lt: BigDecimal
  toAmount_lte: BigDecimal
  toAmount_not: BigDecimal
  toAmount_not_in: [BigDecimal!]
  toSynth: String
  toSynth_: Synth_filter
  toSynth_contains: String
  toSynth_contains_nocase: String
  toSynth_ends_with: String
  toSynth_ends_with_nocase: String
  toSynth_gt: String
  toSynth_gte: String
  toSynth_in: [String!]
  toSynth_lt: String
  toSynth_lte: String
  toSynth_not: String
  toSynth_not_contains: String
  toSynth_not_contains_nocase: String
  toSynth_not_ends_with: String
  toSynth_not_ends_with_nocase: String
  toSynth_not_in: [String!]
  toSynth_not_starts_with: String
  toSynth_not_starts_with_nocase: String
  toSynth_starts_with: String
  toSynth_starts_with_nocase: String
}

enum AtomicSynthExchange_orderBy {
  account
  feesInUSD
  fromAmount
  fromAmountInUSD
  fromSynth
  gasPrice
  id
  timestamp
  toAddress
  toAmount
  toAmountInUSD
  toSynth
}

scalar BigDecimal

scalar BigInt

input BlockChangedFilter {
  number_gte: Int!
}

input Block_height {
  hash: Bytes
  number: Int
  number_gte: Int
}

"""
Burned tracks this event from various Synth.sol instances
"""
type Burned {
  account: Bytes!
  block: BigInt!
  gasPrice: BigInt!
  id: ID!
  source: String!
  timestamp: BigInt!
  value: BigDecimal!
}

input Burned_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  account: Bytes
  account_contains: Bytes
  account_gt: Bytes
  account_gte: Bytes
  account_in: [Bytes!]
  account_lt: Bytes
  account_lte: Bytes
  account_not: Bytes
  account_not_contains: Bytes
  account_not_in: [Bytes!]
  and: [Burned_filter]
  block: BigInt
  block_gt: BigInt
  block_gte: BigInt
  block_in: [BigInt!]
  block_lt: BigInt
  block_lte: BigInt
  block_not: BigInt
  block_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_gt: BigInt
  gasPrice_gte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_lt: BigInt
  gasPrice_lte: BigInt
  gasPrice_not: BigInt
  gasPrice_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [Burned_filter]
  source: String
  source_contains: String
  source_contains_nocase: String
  source_ends_with: String
  source_ends_with_nocase: String
  source_gt: String
  source_gte: String
  source_in: [String!]
  source_lt: String
  source_lte: String
  source_not: String
  source_not_contains: String
  source_not_contains_nocase: String
  source_not_ends_with: String
  source_not_ends_with_nocase: String
  source_not_in: [String!]
  source_not_starts_with: String
  source_not_starts_with_nocase: String
  source_starts_with: String
  source_starts_with_nocase: String
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  value: BigDecimal
  value_gt: BigDecimal
  value_gte: BigDecimal
  value_in: [BigDecimal!]
  value_lt: BigDecimal
  value_lte: BigDecimal
  value_not: BigDecimal
  value_not_in: [BigDecimal!]
}

enum Burned_orderBy {
  account
  block
  gasPrice
  id
  source
  timestamp
  value
}

scalar Bytes

type Candle {
  """
  Number of RateUpdates aggregated into this candle, mostly useful for the indexer to calculate averages
  """
  aggregatedPrices: BigInt!
  average: BigDecimal!
  close: BigDecimal!
  high: BigDecimal!

  """
  synth-period-periodId (periodId is timestamp / period)
  """
  id: ID!
  low: BigDecimal!
  open: BigDecimal!

  """
  Duration this candle captures in seconds. Year, quarter, month, week, day, hour, and 15 minutes available.
  """
  period: BigInt!

  """
  Ticker for synth (e.g. 'sUSD') or 'SNX'
  """
  synth: String!
  timestamp: BigInt!
}

input Candle_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  aggregatedPrices: BigInt
  aggregatedPrices_gt: BigInt
  aggregatedPrices_gte: BigInt
  aggregatedPrices_in: [BigInt!]
  aggregatedPrices_lt: BigInt
  aggregatedPrices_lte: BigInt
  aggregatedPrices_not: BigInt
  aggregatedPrices_not_in: [BigInt!]
  and: [Candle_filter]
  average: BigDecimal
  average_gt: BigDecimal
  average_gte: BigDecimal
  average_in: [BigDecimal!]
  average_lt: BigDecimal
  average_lte: BigDecimal
  average_not: BigDecimal
  average_not_in: [BigDecimal!]
  close: BigDecimal
  close_gt: BigDecimal
  close_gte: BigDecimal
  close_in: [BigDecimal!]
  close_lt: BigDecimal
  close_lte: BigDecimal
  close_not: BigDecimal
  close_not_in: [BigDecimal!]
  high: BigDecimal
  high_gt: BigDecimal
  high_gte: BigDecimal
  high_in: [BigDecimal!]
  high_lt: BigDecimal
  high_lte: BigDecimal
  high_not: BigDecimal
  high_not_in: [BigDecimal!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  low: BigDecimal
  low_gt: BigDecimal
  low_gte: BigDecimal
  low_in: [BigDecimal!]
  low_lt: BigDecimal
  low_lte: BigDecimal
  low_not: BigDecimal
  low_not_in: [BigDecimal!]
  open: BigDecimal
  open_gt: BigDecimal
  open_gte: BigDecimal
  open_in: [BigDecimal!]
  open_lt: BigDecimal
  open_lte: BigDecimal
  open_not: BigDecimal
  open_not_in: [BigDecimal!]
  or: [Candle_filter]
  period: BigInt
  period_gt: BigInt
  period_gte: BigInt
  period_in: [BigInt!]
  period_lt: BigInt
  period_lte: BigInt
  period_not: BigInt
  period_not_in: [BigInt!]
  synth: String
  synth_contains: String
  synth_contains_nocase: String
  synth_ends_with: String
  synth_ends_with_nocase: String
  synth_gt: String
  synth_gte: String
  synth_in: [String!]
  synth_lt: String
  synth_lte: String
  synth_not: String
  synth_not_contains: String
  synth_not_contains_nocase: String
  synth_not_ends_with: String
  synth_not_ends_with_nocase: String
  synth_not_in: [String!]
  synth_not_starts_with: String
  synth_not_starts_with_nocase: String
  synth_starts_with: String
  synth_starts_with_nocase: String
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
}

enum Candle_orderBy {
  aggregatedPrices
  average
  close
  high
  id
  low
  open
  period
  synth
  timestamp
}

type CollateralDeposited {
  """
  the account that created the loan
  """
  account: Bytes!

  """
  the total amount of collateral after the deposit is included
  """
  collateralAfter: BigDecimal!

  """
  the amount of collateral deposited
  """
  collateralAmount: BigDecimal!

  """
  the event tx hash plus event log index
  """
  id: ID!

  """
  the loan id
  """
  loanId: BigInt!

  """
  the timestamp collateral was deposited
  """
  timestamp: BigInt!
}

input CollateralDeposited_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  account: Bytes
  account_contains: Bytes
  account_gt: Bytes
  account_gte: Bytes
  account_in: [Bytes!]
  account_lt: Bytes
  account_lte: Bytes
  account_not: Bytes
  account_not_contains: Bytes
  account_not_in: [Bytes!]
  and: [CollateralDeposited_filter]
  collateralAfter: BigDecimal
  collateralAfter_gt: BigDecimal
  collateralAfter_gte: BigDecimal
  collateralAfter_in: [BigDecimal!]
  collateralAfter_lt: BigDecimal
  collateralAfter_lte: BigDecimal
  collateralAfter_not: BigDecimal
  collateralAfter_not_in: [BigDecimal!]
  collateralAmount: BigDecimal
  collateralAmount_gt: BigDecimal
  collateralAmount_gte: BigDecimal
  collateralAmount_in: [BigDecimal!]
  collateralAmount_lt: BigDecimal
  collateralAmount_lte: BigDecimal
  collateralAmount_not: BigDecimal
  collateralAmount_not_in: [BigDecimal!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  loanId: BigInt
  loanId_gt: BigInt
  loanId_gte: BigInt
  loanId_in: [BigInt!]
  loanId_lt: BigInt
  loanId_lte: BigInt
  loanId_not: BigInt
  loanId_not_in: [BigInt!]
  or: [CollateralDeposited_filter]
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
}

enum CollateralDeposited_orderBy {
  account
  collateralAfter
  collateralAmount
  id
  loanId
  timestamp
}

type CollateralWithdrawn {
  """
  the account that created the loan
  """
  account: Bytes!

  """
  the amount of collateral withdrawn
  """
  amountWithdrawn: BigDecimal!

  """
  the total amount of collateral after the withdrawal is accounted for
  """
  collateralAfter: BigDecimal!

  """
  the event tx hash plus event log index
  """
  id: ID!

  """
  the loan id
  """
  loanId: BigInt!

  """
  the timestamp collateral was withdrawn
  """
  timestamp: BigInt!
}

input CollateralWithdrawn_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  account: Bytes
  account_contains: Bytes
  account_gt: Bytes
  account_gte: Bytes
  account_in: [Bytes!]
  account_lt: Bytes
  account_lte: Bytes
  account_not: Bytes
  account_not_contains: Bytes
  account_not_in: [Bytes!]
  amountWithdrawn: BigDecimal
  amountWithdrawn_gt: BigDecimal
  amountWithdrawn_gte: BigDecimal
  amountWithdrawn_in: [BigDecimal!]
  amountWithdrawn_lt: BigDecimal
  amountWithdrawn_lte: BigDecimal
  amountWithdrawn_not: BigDecimal
  amountWithdrawn_not_in: [BigDecimal!]
  and: [CollateralWithdrawn_filter]
  collateralAfter: BigDecimal
  collateralAfter_gt: BigDecimal
  collateralAfter_gte: BigDecimal
  collateralAfter_in: [BigDecimal!]
  collateralAfter_lt: BigDecimal
  collateralAfter_lte: BigDecimal
  collateralAfter_not: BigDecimal
  collateralAfter_not_in: [BigDecimal!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  loanId: BigInt
  loanId_gt: BigInt
  loanId_gte: BigInt
  loanId_in: [BigInt!]
  loanId_lt: BigInt
  loanId_lte: BigInt
  loanId_not: BigInt
  loanId_not_in: [BigInt!]
  or: [CollateralWithdrawn_filter]
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
}

enum CollateralWithdrawn_orderBy {
  account
  amountWithdrawn
  collateralAfter
  id
  loanId
  timestamp
}

type DailyBurned {
  """
  unix timestamp at beginning of day of the measurement
  """
  id: ID!

  """
  amount of debt as of the last event for this day
  """
  totalDebt: BigDecimal!

  """
  amount burned
  """
  value: BigDecimal!
}

input DailyBurned_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [DailyBurned_filter]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [DailyBurned_filter]
  totalDebt: BigDecimal
  totalDebt_gt: BigDecimal
  totalDebt_gte: BigDecimal
  totalDebt_in: [BigDecimal!]
  totalDebt_lt: BigDecimal
  totalDebt_lte: BigDecimal
  totalDebt_not: BigDecimal
  totalDebt_not_in: [BigDecimal!]
  value: BigDecimal
  value_gt: BigDecimal
  value_gte: BigDecimal
  value_in: [BigDecimal!]
  value_lt: BigDecimal
  value_lte: BigDecimal
  value_not: BigDecimal
  value_not_in: [BigDecimal!]
}

enum DailyBurned_orderBy {
  id
  totalDebt
  value
}

"""
DEPRECATED: See the Candles entity
"""
type DailyCandle {
  close: BigDecimal!
  high: BigDecimal!

  """
  DEPRECATED: See the Candles entity
  """
  id: ID!
  low: BigDecimal!
  open: BigDecimal!
  synth: String!
  timestamp: BigInt!
}

input DailyCandle_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [DailyCandle_filter]
  close: BigDecimal
  close_gt: BigDecimal
  close_gte: BigDecimal
  close_in: [BigDecimal!]
  close_lt: BigDecimal
  close_lte: BigDecimal
  close_not: BigDecimal
  close_not_in: [BigDecimal!]
  high: BigDecimal
  high_gt: BigDecimal
  high_gte: BigDecimal
  high_in: [BigDecimal!]
  high_lt: BigDecimal
  high_lte: BigDecimal
  high_not: BigDecimal
  high_not_in: [BigDecimal!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  low: BigDecimal
  low_gt: BigDecimal
  low_gte: BigDecimal
  low_in: [BigDecimal!]
  low_lt: BigDecimal
  low_lte: BigDecimal
  low_not: BigDecimal
  low_not_in: [BigDecimal!]
  open: BigDecimal
  open_gt: BigDecimal
  open_gte: BigDecimal
  open_in: [BigDecimal!]
  open_lt: BigDecimal
  open_lte: BigDecimal
  open_not: BigDecimal
  open_not_in: [BigDecimal!]
  or: [DailyCandle_filter]
  synth: String
  synth_contains: String
  synth_contains_nocase: String
  synth_ends_with: String
  synth_ends_with_nocase: String
  synth_gt: String
  synth_gte: String
  synth_in: [String!]
  synth_lt: String
  synth_lte: String
  synth_not: String
  synth_not_contains: String
  synth_not_contains_nocase: String
  synth_not_ends_with: String
  synth_not_ends_with_nocase: String
  synth_not_in: [String!]
  synth_not_starts_with: String
  synth_not_starts_with_nocase: String
  synth_starts_with: String
  synth_starts_with_nocase: String
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
}

enum DailyCandle_orderBy {
  close
  high
  id
  low
  open
  synth
  timestamp
}

type DailyExchangePartner {
  """
  Day timestamp + tracking code of the partner
  """
  id: ID!

  """
  Tracking code of the partner
  """
  partner: String!

  """
  unix timestamp at the beginning of the day
  """
  timestamp: BigInt!

  """
  Total number of trades from the volume partner for this day
  """
  trades: BigInt!

  """
  Total fees generated by the volume partner for this day
  """
  usdFees: BigDecimal!

  """
  Total transaction volume in USD for the partner on this day
  """
  usdVolume: BigDecimal!
}

input DailyExchangePartner_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [DailyExchangePartner_filter]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [DailyExchangePartner_filter]
  partner: String
  partner_contains: String
  partner_contains_nocase: String
  partner_ends_with: String
  partner_ends_with_nocase: String
  partner_gt: String
  partner_gte: String
  partner_in: [String!]
  partner_lt: String
  partner_lte: String
  partner_not: String
  partner_not_contains: String
  partner_not_contains_nocase: String
  partner_not_ends_with: String
  partner_not_ends_with_nocase: String
  partner_not_in: [String!]
  partner_not_starts_with: String
  partner_not_starts_with_nocase: String
  partner_starts_with: String
  partner_starts_with_nocase: String
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  trades: BigInt
  trades_gt: BigInt
  trades_gte: BigInt
  trades_in: [BigInt!]
  trades_lt: BigInt
  trades_lte: BigInt
  trades_not: BigInt
  trades_not_in: [BigInt!]
  usdFees: BigDecimal
  usdFees_gt: BigDecimal
  usdFees_gte: BigDecimal
  usdFees_in: [BigDecimal!]
  usdFees_lt: BigDecimal
  usdFees_lte: BigDecimal
  usdFees_not: BigDecimal
  usdFees_not_in: [BigDecimal!]
  usdVolume: BigDecimal
  usdVolume_gt: BigDecimal
  usdVolume_gte: BigDecimal
  usdVolume_in: [BigDecimal!]
  usdVolume_lt: BigDecimal
  usdVolume_lte: BigDecimal
  usdVolume_not: BigDecimal
  usdVolume_not_in: [BigDecimal!]
}

enum DailyExchangePartner_orderBy {
  id
  partner
  timestamp
  trades
  usdFees
  usdVolume
}

type DailyIssued {
  """
  unix timestamp at beginning of day of the measurement
  """
  id: ID!

  """
  amount of debt as of the last event for this day
  """
  totalDebt: BigDecimal!

  """
  amount issued
  """
  value: BigDecimal!
}

input DailyIssued_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [DailyIssued_filter]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [DailyIssued_filter]
  totalDebt: BigDecimal
  totalDebt_gt: BigDecimal
  totalDebt_gte: BigDecimal
  totalDebt_in: [BigDecimal!]
  totalDebt_lt: BigDecimal
  totalDebt_lte: BigDecimal
  totalDebt_not: BigDecimal
  totalDebt_not_in: [BigDecimal!]
  value: BigDecimal
  value_gt: BigDecimal
  value_gte: BigDecimal
  value_in: [BigDecimal!]
  value_lt: BigDecimal
  value_lte: BigDecimal
  value_not: BigDecimal
  value_not_in: [BigDecimal!]
}

enum DailyIssued_orderBy {
  id
  totalDebt
  value
}

"""
A historical debt tracker
"""
type DebtSnapshot {
  """
  address for which these statistics are applicable
  """
  account: Bytes!
  balanceOf: BigDecimal

  """
  last block where an event happened
  """
  block: BigInt!

  """
  SNX which is being used for collateral as of last event and cannot be spent
  """
  collateral: BigDecimal

  """
  sUSD of debt as of last event
  """
  debtBalanceOf: BigDecimal

  """
  debt entry when `initialDebtOwnership` applies
  """
  debtEntryAtIndex: BigInt
  id: ID!

  """
  sUSD debt portion a user had at last index
  """
  initialDebtOwnership: BigDecimal

  """
  last time when an event happened
  """
  timestamp: BigInt!
}

input DebtSnapshot_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  account: Bytes
  account_contains: Bytes
  account_gt: Bytes
  account_gte: Bytes
  account_in: [Bytes!]
  account_lt: Bytes
  account_lte: Bytes
  account_not: Bytes
  account_not_contains: Bytes
  account_not_in: [Bytes!]
  and: [DebtSnapshot_filter]
  balanceOf: BigDecimal
  balanceOf_gt: BigDecimal
  balanceOf_gte: BigDecimal
  balanceOf_in: [BigDecimal!]
  balanceOf_lt: BigDecimal
  balanceOf_lte: BigDecimal
  balanceOf_not: BigDecimal
  balanceOf_not_in: [BigDecimal!]
  block: BigInt
  block_gt: BigInt
  block_gte: BigInt
  block_in: [BigInt!]
  block_lt: BigInt
  block_lte: BigInt
  block_not: BigInt
  block_not_in: [BigInt!]
  collateral: BigDecimal
  collateral_gt: BigDecimal
  collateral_gte: BigDecimal
  collateral_in: [BigDecimal!]
  collateral_lt: BigDecimal
  collateral_lte: BigDecimal
  collateral_not: BigDecimal
  collateral_not_in: [BigDecimal!]
  debtBalanceOf: BigDecimal
  debtBalanceOf_gt: BigDecimal
  debtBalanceOf_gte: BigDecimal
  debtBalanceOf_in: [BigDecimal!]
  debtBalanceOf_lt: BigDecimal
  debtBalanceOf_lte: BigDecimal
  debtBalanceOf_not: BigDecimal
  debtBalanceOf_not_in: [BigDecimal!]
  debtEntryAtIndex: BigInt
  debtEntryAtIndex_gt: BigInt
  debtEntryAtIndex_gte: BigInt
  debtEntryAtIndex_in: [BigInt!]
  debtEntryAtIndex_lt: BigInt
  debtEntryAtIndex_lte: BigInt
  debtEntryAtIndex_not: BigInt
  debtEntryAtIndex_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  initialDebtOwnership: BigDecimal
  initialDebtOwnership_gt: BigDecimal
  initialDebtOwnership_gte: BigDecimal
  initialDebtOwnership_in: [BigDecimal!]
  initialDebtOwnership_lt: BigDecimal
  initialDebtOwnership_lte: BigDecimal
  initialDebtOwnership_not: BigDecimal
  initialDebtOwnership_not_in: [BigDecimal!]
  or: [DebtSnapshot_filter]
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
}

enum DebtSnapshot_orderBy {
  account
  balanceOf
  block
  collateral
  debtBalanceOf
  debtEntryAtIndex
  id
  initialDebtOwnership
  timestamp
}

type DebtState {
  """
  representation of total amount of debt issued over time. increases or decreases proportionally whenever synths are minted/burned
  """
  debtEntry: BigDecimal!

  """
  totalIssuedSynths / debtEntry - useful for tracking debt over time
  """
  debtRatio: BigDecimal!

  """
  Global historical debt entry index
  """
  id: ID!
  period: BigInt!

  """
  time at which these values are recorded
  """
  timestamp: BigInt!

  """
  current value of all issued synths which this debt pool is responsible for. fluctuates based on the synth breakdown of the system * exchange rates
  """
  totalIssuedSynths: BigDecimal!
}

input DebtState_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [DebtState_filter]
  debtEntry: BigDecimal
  debtEntry_gt: BigDecimal
  debtEntry_gte: BigDecimal
  debtEntry_in: [BigDecimal!]
  debtEntry_lt: BigDecimal
  debtEntry_lte: BigDecimal
  debtEntry_not: BigDecimal
  debtEntry_not_in: [BigDecimal!]
  debtRatio: BigDecimal
  debtRatio_gt: BigDecimal
  debtRatio_gte: BigDecimal
  debtRatio_in: [BigDecimal!]
  debtRatio_lt: BigDecimal
  debtRatio_lte: BigDecimal
  debtRatio_not: BigDecimal
  debtRatio_not_in: [BigDecimal!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [DebtState_filter]
  period: BigInt
  period_gt: BigInt
  period_gte: BigInt
  period_in: [BigInt!]
  period_lt: BigInt
  period_lte: BigInt
  period_not: BigInt
  period_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  totalIssuedSynths: BigDecimal
  totalIssuedSynths_gt: BigDecimal
  totalIssuedSynths_gte: BigDecimal
  totalIssuedSynths_in: [BigDecimal!]
  totalIssuedSynths_lt: BigDecimal
  totalIssuedSynths_lte: BigDecimal
  totalIssuedSynths_not: BigDecimal
  totalIssuedSynths_not_in: [BigDecimal!]
}

enum DebtState_orderBy {
  debtEntry
  debtRatio
  id
  period
  timestamp
  totalIssuedSynths
}

type DelegatedWallet {
  authoriser: Bytes!
  canBurn: Boolean
  canClaim: Boolean
  canExchange: Boolean
  canMint: Boolean
  delegate: Bytes!

  """
  authoriser-delegate
  """
  id: ID!
}

input DelegatedWallet_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [DelegatedWallet_filter]
  authoriser: Bytes
  authoriser_contains: Bytes
  authoriser_gt: Bytes
  authoriser_gte: Bytes
  authoriser_in: [Bytes!]
  authoriser_lt: Bytes
  authoriser_lte: Bytes
  authoriser_not: Bytes
  authoriser_not_contains: Bytes
  authoriser_not_in: [Bytes!]
  canBurn: Boolean
  canBurn_in: [Boolean!]
  canBurn_not: Boolean
  canBurn_not_in: [Boolean!]
  canClaim: Boolean
  canClaim_in: [Boolean!]
  canClaim_not: Boolean
  canClaim_not_in: [Boolean!]
  canExchange: Boolean
  canExchange_in: [Boolean!]
  canExchange_not: Boolean
  canExchange_not_in: [Boolean!]
  canMint: Boolean
  canMint_in: [Boolean!]
  canMint_not: Boolean
  canMint_not_in: [Boolean!]
  delegate: Bytes
  delegate_contains: Bytes
  delegate_gt: Bytes
  delegate_gte: Bytes
  delegate_in: [Bytes!]
  delegate_lt: Bytes
  delegate_lte: Bytes
  delegate_not: Bytes
  delegate_not_contains: Bytes
  delegate_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [DelegatedWallet_filter]
}

enum DelegatedWallet_orderBy {
  authoriser
  canBurn
  canClaim
  canExchange
  canMint
  delegate
  id
}

type ExchangeEntryAppended {
  """
  ethereum address which funded the exchange
  """
  account: Bytes!

  """
  number of units of synth from exchanged
  """
  amount: BigDecimal!

  """
  number of units of synth to received
  """
  amountReceived: BigDecimal!

  """
  synth exchanged to
  """
  dest: Bytes!

  """
  fee paid in sUSD to the synthetix fee pool
  """
  exchangeFeeRate: BigDecimal!

  """
  transaction hash and log index
  """
  id: ID!

  """
  aggregator price round for dest synth
  """
  roundIdForDest: BigInt!

  """
  aggregator price round for src synth
  """
  roundIdForSrc: BigInt!

  """
  synth exchanged from
  """
  src: Bytes!
}

input ExchangeEntryAppended_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  account: Bytes
  account_contains: Bytes
  account_gt: Bytes
  account_gte: Bytes
  account_in: [Bytes!]
  account_lt: Bytes
  account_lte: Bytes
  account_not: Bytes
  account_not_contains: Bytes
  account_not_in: [Bytes!]
  amount: BigDecimal
  amountReceived: BigDecimal
  amountReceived_gt: BigDecimal
  amountReceived_gte: BigDecimal
  amountReceived_in: [BigDecimal!]
  amountReceived_lt: BigDecimal
  amountReceived_lte: BigDecimal
  amountReceived_not: BigDecimal
  amountReceived_not_in: [BigDecimal!]
  amount_gt: BigDecimal
  amount_gte: BigDecimal
  amount_in: [BigDecimal!]
  amount_lt: BigDecimal
  amount_lte: BigDecimal
  amount_not: BigDecimal
  amount_not_in: [BigDecimal!]
  and: [ExchangeEntryAppended_filter]
  dest: Bytes
  dest_contains: Bytes
  dest_gt: Bytes
  dest_gte: Bytes
  dest_in: [Bytes!]
  dest_lt: Bytes
  dest_lte: Bytes
  dest_not: Bytes
  dest_not_contains: Bytes
  dest_not_in: [Bytes!]
  exchangeFeeRate: BigDecimal
  exchangeFeeRate_gt: BigDecimal
  exchangeFeeRate_gte: BigDecimal
  exchangeFeeRate_in: [BigDecimal!]
  exchangeFeeRate_lt: BigDecimal
  exchangeFeeRate_lte: BigDecimal
  exchangeFeeRate_not: BigDecimal
  exchangeFeeRate_not_in: [BigDecimal!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [ExchangeEntryAppended_filter]
  roundIdForDest: BigInt
  roundIdForDest_gt: BigInt
  roundIdForDest_gte: BigInt
  roundIdForDest_in: [BigInt!]
  roundIdForDest_lt: BigInt
  roundIdForDest_lte: BigInt
  roundIdForDest_not: BigInt
  roundIdForDest_not_in: [BigInt!]
  roundIdForSrc: BigInt
  roundIdForSrc_gt: BigInt
  roundIdForSrc_gte: BigInt
  roundIdForSrc_in: [BigInt!]
  roundIdForSrc_lt: BigInt
  roundIdForSrc_lte: BigInt
  roundIdForSrc_not: BigInt
  roundIdForSrc_not_in: [BigInt!]
  src: Bytes
  src_contains: Bytes
  src_gt: Bytes
  src_gte: Bytes
  src_in: [Bytes!]
  src_lt: Bytes
  src_lte: Bytes
  src_not: Bytes
  src_not_contains: Bytes
  src_not_in: [Bytes!]
}

enum ExchangeEntryAppended_orderBy {
  account
  amount
  amountReceived
  dest
  exchangeFeeRate
  id
  roundIdForDest
  roundIdForSrc
  src
}

type ExchangeEntrySettled {
  """
  number of units of synth from exchanged
  """
  amount: BigDecimal!

  """
  address which receives the settlement
  """
  dest: Bytes!

  """
  aggregator price round for dest synth
  """
  destRoundIdAtPeriodEnd: BigInt!

  """
  time when the original exchange occured
  """
  exchangeTimestamp: BigInt!

  """
  synth exchanged from
  """
  from: Bytes!

  """
  transaction hash and log index
  """
  id: ID!

  """
  amount returned of dest due to overpayment
  """
  rebate: BigDecimal!

  """
  amount reclaimed of dest due to underpayment
  """
  reclaim: BigDecimal!

  """
  synth exchanged to
  """
  src: Bytes!

  """
  aggregator price round for src synth
  """
  srcRoundIdAtPeriodEnd: BigInt!
}

input ExchangeEntrySettled_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  amount: BigDecimal
  amount_gt: BigDecimal
  amount_gte: BigDecimal
  amount_in: [BigDecimal!]
  amount_lt: BigDecimal
  amount_lte: BigDecimal
  amount_not: BigDecimal
  amount_not_in: [BigDecimal!]
  and: [ExchangeEntrySettled_filter]
  dest: Bytes
  destRoundIdAtPeriodEnd: BigInt
  destRoundIdAtPeriodEnd_gt: BigInt
  destRoundIdAtPeriodEnd_gte: BigInt
  destRoundIdAtPeriodEnd_in: [BigInt!]
  destRoundIdAtPeriodEnd_lt: BigInt
  destRoundIdAtPeriodEnd_lte: BigInt
  destRoundIdAtPeriodEnd_not: BigInt
  destRoundIdAtPeriodEnd_not_in: [BigInt!]
  dest_contains: Bytes
  dest_gt: Bytes
  dest_gte: Bytes
  dest_in: [Bytes!]
  dest_lt: Bytes
  dest_lte: Bytes
  dest_not: Bytes
  dest_not_contains: Bytes
  dest_not_in: [Bytes!]
  exchangeTimestamp: BigInt
  exchangeTimestamp_gt: BigInt
  exchangeTimestamp_gte: BigInt
  exchangeTimestamp_in: [BigInt!]
  exchangeTimestamp_lt: BigInt
  exchangeTimestamp_lte: BigInt
  exchangeTimestamp_not: BigInt
  exchangeTimestamp_not_in: [BigInt!]
  from: Bytes
  from_contains: Bytes
  from_gt: Bytes
  from_gte: Bytes
  from_in: [Bytes!]
  from_lt: Bytes
  from_lte: Bytes
  from_not: Bytes
  from_not_contains: Bytes
  from_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [ExchangeEntrySettled_filter]
  rebate: BigDecimal
  rebate_gt: BigDecimal
  rebate_gte: BigDecimal
  rebate_in: [BigDecimal!]
  rebate_lt: BigDecimal
  rebate_lte: BigDecimal
  rebate_not: BigDecimal
  rebate_not_in: [BigDecimal!]
  reclaim: BigDecimal
  reclaim_gt: BigDecimal
  reclaim_gte: BigDecimal
  reclaim_in: [BigDecimal!]
  reclaim_lt: BigDecimal
  reclaim_lte: BigDecimal
  reclaim_not: BigDecimal
  reclaim_not_in: [BigDecimal!]
  src: Bytes
  srcRoundIdAtPeriodEnd: BigInt
  srcRoundIdAtPeriodEnd_gt: BigInt
  srcRoundIdAtPeriodEnd_gte: BigInt
  srcRoundIdAtPeriodEnd_in: [BigInt!]
  srcRoundIdAtPeriodEnd_lt: BigInt
  srcRoundIdAtPeriodEnd_lte: BigInt
  srcRoundIdAtPeriodEnd_not: BigInt
  srcRoundIdAtPeriodEnd_not_in: [BigInt!]
  src_contains: Bytes
  src_gt: Bytes
  src_gte: Bytes
  src_in: [Bytes!]
  src_lt: Bytes
  src_lte: Bytes
  src_not: Bytes
  src_not_contains: Bytes
  src_not_in: [Bytes!]
}

enum ExchangeEntrySettled_orderBy {
  amount
  dest
  destRoundIdAtPeriodEnd
  exchangeTimestamp
  from
  id
  rebate
  reclaim
  src
  srcRoundIdAtPeriodEnd
}

type ExchangeFee {
  """
  Current Fee as a ratio of the trade amount
  """
  fee: BigDecimal!

  """
  Name of the synth. E.g. sUSD
  """
  id: ID!
}

input ExchangeFee_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [ExchangeFee_filter]
  fee: BigDecimal
  fee_gt: BigDecimal
  fee_gte: BigDecimal
  fee_in: [BigDecimal!]
  fee_lt: BigDecimal
  fee_lte: BigDecimal
  fee_not: BigDecimal
  fee_not_in: [BigDecimal!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [ExchangeFee_filter]
}

enum ExchangeFee_orderBy {
  fee
  id
}

type ExchangePartner {
  """
  Tracking code of the partner
  """
  id: ID!

  """
  Total number of trades from the volume partner
  """
  trades: BigInt!

  """
  Total fees generated by the volume partner
  """
  usdFees: BigDecimal!

  """
  Total transaction volume in USD for the partner
  """
  usdVolume: BigDecimal!
}

input ExchangePartner_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [ExchangePartner_filter]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [ExchangePartner_filter]
  trades: BigInt
  trades_gt: BigInt
  trades_gte: BigInt
  trades_in: [BigInt!]
  trades_lt: BigInt
  trades_lte: BigInt
  trades_not: BigInt
  trades_not_in: [BigInt!]
  usdFees: BigDecimal
  usdFees_gt: BigDecimal
  usdFees_gte: BigDecimal
  usdFees_in: [BigDecimal!]
  usdFees_lt: BigDecimal
  usdFees_lte: BigDecimal
  usdFees_not: BigDecimal
  usdFees_not_in: [BigDecimal!]
  usdVolume: BigDecimal
  usdVolume_gt: BigDecimal
  usdVolume_gte: BigDecimal
  usdVolume_in: [BigDecimal!]
  usdVolume_lt: BigDecimal
  usdVolume_lte: BigDecimal
  usdVolume_not: BigDecimal
  usdVolume_not_in: [BigDecimal!]
}

enum ExchangePartner_orderBy {
  id
  trades
  usdFees
  usdVolume
}

"""
Tracks this event from the Synthetix.sol contract
"""
type ExchangeRebate {
  account: Exchanger!
  amount: BigDecimal!
  amountInUSD: BigDecimal!
  block: BigInt!
  currencyKey: Bytes!
  gasPrice: BigInt!
  id: ID!
  timestamp: BigInt!
}

input ExchangeRebate_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  account: String
  account_: Exchanger_filter
  account_contains: String
  account_contains_nocase: String
  account_ends_with: String
  account_ends_with_nocase: String
  account_gt: String
  account_gte: String
  account_in: [String!]
  account_lt: String
  account_lte: String
  account_not: String
  account_not_contains: String
  account_not_contains_nocase: String
  account_not_ends_with: String
  account_not_ends_with_nocase: String
  account_not_in: [String!]
  account_not_starts_with: String
  account_not_starts_with_nocase: String
  account_starts_with: String
  account_starts_with_nocase: String
  amount: BigDecimal
  amountInUSD: BigDecimal
  amountInUSD_gt: BigDecimal
  amountInUSD_gte: BigDecimal
  amountInUSD_in: [BigDecimal!]
  amountInUSD_lt: BigDecimal
  amountInUSD_lte: BigDecimal
  amountInUSD_not: BigDecimal
  amountInUSD_not_in: [BigDecimal!]
  amount_gt: BigDecimal
  amount_gte: BigDecimal
  amount_in: [BigDecimal!]
  amount_lt: BigDecimal
  amount_lte: BigDecimal
  amount_not: BigDecimal
  amount_not_in: [BigDecimal!]
  and: [ExchangeRebate_filter]
  block: BigInt
  block_gt: BigInt
  block_gte: BigInt
  block_in: [BigInt!]
  block_lt: BigInt
  block_lte: BigInt
  block_not: BigInt
  block_not_in: [BigInt!]
  currencyKey: Bytes
  currencyKey_contains: Bytes
  currencyKey_gt: Bytes
  currencyKey_gte: Bytes
  currencyKey_in: [Bytes!]
  currencyKey_lt: Bytes
  currencyKey_lte: Bytes
  currencyKey_not: Bytes
  currencyKey_not_contains: Bytes
  currencyKey_not_in: [Bytes!]
  gasPrice: BigInt
  gasPrice_gt: BigInt
  gasPrice_gte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_lt: BigInt
  gasPrice_lte: BigInt
  gasPrice_not: BigInt
  gasPrice_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [ExchangeRebate_filter]
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
}

enum ExchangeRebate_orderBy {
  account
  amount
  amountInUSD
  block
  currencyKey
  gasPrice
  id
  timestamp
}

"""
Tracks this event from the Synthetix.sol contract
"""
type ExchangeReclaim {
  account: Exchanger!
  amount: BigDecimal!
  amountInUSD: BigDecimal!
  block: BigInt!
  currencyKey: Bytes!
  gasPrice: BigInt!
  id: ID!
  timestamp: BigInt!
}

input ExchangeReclaim_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  account: String
  account_: Exchanger_filter
  account_contains: String
  account_contains_nocase: String
  account_ends_with: String
  account_ends_with_nocase: String
  account_gt: String
  account_gte: String
  account_in: [String!]
  account_lt: String
  account_lte: String
  account_not: String
  account_not_contains: String
  account_not_contains_nocase: String
  account_not_ends_with: String
  account_not_ends_with_nocase: String
  account_not_in: [String!]
  account_not_starts_with: String
  account_not_starts_with_nocase: String
  account_starts_with: String
  account_starts_with_nocase: String
  amount: BigDecimal
  amountInUSD: BigDecimal
  amountInUSD_gt: BigDecimal
  amountInUSD_gte: BigDecimal
  amountInUSD_in: [BigDecimal!]
  amountInUSD_lt: BigDecimal
  amountInUSD_lte: BigDecimal
  amountInUSD_not: BigDecimal
  amountInUSD_not_in: [BigDecimal!]
  amount_gt: BigDecimal
  amount_gte: BigDecimal
  amount_in: [BigDecimal!]
  amount_lt: BigDecimal
  amount_lte: BigDecimal
  amount_not: BigDecimal
  amount_not_in: [BigDecimal!]
  and: [ExchangeReclaim_filter]
  block: BigInt
  block_gt: BigInt
  block_gte: BigInt
  block_in: [BigInt!]
  block_lt: BigInt
  block_lte: BigInt
  block_not: BigInt
  block_not_in: [BigInt!]
  currencyKey: Bytes
  currencyKey_contains: Bytes
  currencyKey_gt: Bytes
  currencyKey_gte: Bytes
  currencyKey_in: [Bytes!]
  currencyKey_lt: Bytes
  currencyKey_lte: Bytes
  currencyKey_not: Bytes
  currencyKey_not_contains: Bytes
  currencyKey_not_in: [Bytes!]
  gasPrice: BigInt
  gasPrice_gt: BigInt
  gasPrice_gte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_lt: BigInt
  gasPrice_lte: BigInt
  gasPrice_not: BigInt
  gasPrice_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [ExchangeReclaim_filter]
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
}

enum ExchangeReclaim_orderBy {
  account
  amount
  amountInUSD
  block
  currencyKey
  gasPrice
  id
  timestamp
}

"""
An individual Exchanger aggregated by various time groupings
"""
type Exchanger {
  """
  balances
  """
  balances(
    first: Int = 100
    orderBy: LatestSynthBalance_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: LatestSynthBalance_filter
  ): [LatestSynthBalance!]!

  """
  minimum power of 10 (in from USD value) the trade must be. ex, 2 means $100 or higher)
  """
  bucketMagnitude: BigInt!

  """
  synth value exchanged in USD units by account
  """
  exchangeUSDTally: BigDecimal!

  """
  exchanges
  """
  exchanges(
    first: Int = 100
    orderBy: SynthExchange_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: SynthExchange_filter
  ): [SynthExchange!]!

  """
  when the user first exchanged
  """
  firstSeen: BigInt!

  """
  hex address in lowercase (and for non global: hex address in lowercase-$timestamp-$period-$bucketMagnitude-$synth
  """
  id: ID!

  """
  when the user last exchanged
  """
  lastSeen: BigInt!

  """
  number of seconds the data covers after `timestamp`, or 0 for no period filter
  """
  period: BigInt!

  """
  synth to filter by
  """
  synth: Synth

  """
  timestamp of the beginning of the time period this represents, or 0 for no period filter
  """
  timestamp: BigInt!

  """
  synth value received in fees in USD units from account
  """
  totalFeesGeneratedInUSD: BigDecimal!

  """
  nubmer of trades by account
  """
  trades: BigInt!
}

input Exchanger_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [Exchanger_filter]
  balances: [String!]
  balances_: LatestSynthBalance_filter
  balances_contains: [String!]
  balances_contains_nocase: [String!]
  balances_not: [String!]
  balances_not_contains: [String!]
  balances_not_contains_nocase: [String!]
  bucketMagnitude: BigInt
  bucketMagnitude_gt: BigInt
  bucketMagnitude_gte: BigInt
  bucketMagnitude_in: [BigInt!]
  bucketMagnitude_lt: BigInt
  bucketMagnitude_lte: BigInt
  bucketMagnitude_not: BigInt
  bucketMagnitude_not_in: [BigInt!]
  exchangeUSDTally: BigDecimal
  exchangeUSDTally_gt: BigDecimal
  exchangeUSDTally_gte: BigDecimal
  exchangeUSDTally_in: [BigDecimal!]
  exchangeUSDTally_lt: BigDecimal
  exchangeUSDTally_lte: BigDecimal
  exchangeUSDTally_not: BigDecimal
  exchangeUSDTally_not_in: [BigDecimal!]
  exchanges_: SynthExchange_filter
  firstSeen: BigInt
  firstSeen_gt: BigInt
  firstSeen_gte: BigInt
  firstSeen_in: [BigInt!]
  firstSeen_lt: BigInt
  firstSeen_lte: BigInt
  firstSeen_not: BigInt
  firstSeen_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  lastSeen: BigInt
  lastSeen_gt: BigInt
  lastSeen_gte: BigInt
  lastSeen_in: [BigInt!]
  lastSeen_lt: BigInt
  lastSeen_lte: BigInt
  lastSeen_not: BigInt
  lastSeen_not_in: [BigInt!]
  or: [Exchanger_filter]
  period: BigInt
  period_gt: BigInt
  period_gte: BigInt
  period_in: [BigInt!]
  period_lt: BigInt
  period_lte: BigInt
  period_not: BigInt
  period_not_in: [BigInt!]
  synth: String
  synth_: Synth_filter
  synth_contains: String
  synth_contains_nocase: String
  synth_ends_with: String
  synth_ends_with_nocase: String
  synth_gt: String
  synth_gte: String
  synth_in: [String!]
  synth_lt: String
  synth_lte: String
  synth_not: String
  synth_not_contains: String
  synth_not_contains_nocase: String
  synth_not_ends_with: String
  synth_not_ends_with_nocase: String
  synth_not_in: [String!]
  synth_not_starts_with: String
  synth_not_starts_with_nocase: String
  synth_starts_with: String
  synth_starts_with_nocase: String
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  totalFeesGeneratedInUSD: BigDecimal
  totalFeesGeneratedInUSD_gt: BigDecimal
  totalFeesGeneratedInUSD_gte: BigDecimal
  totalFeesGeneratedInUSD_in: [BigDecimal!]
  totalFeesGeneratedInUSD_lt: BigDecimal
  totalFeesGeneratedInUSD_lte: BigDecimal
  totalFeesGeneratedInUSD_not: BigDecimal
  totalFeesGeneratedInUSD_not_in: [BigDecimal!]
  trades: BigInt
  trades_gt: BigInt
  trades_gte: BigInt
  trades_in: [BigInt!]
  trades_lt: BigInt
  trades_lte: BigInt
  trades_not: BigInt
  trades_not_in: [BigInt!]
}

enum Exchanger_orderBy {
  balances
  bucketMagnitude
  exchangeUSDTally
  exchanges
  firstSeen
  id
  lastSeen
  period
  synth
  timestamp
  totalFeesGeneratedInUSD
  trades
}

type FeePeriod {
  feesClaimed: BigDecimal!
  feesToDistribute: BigDecimal!
  id: ID!
  rewardsClaimed: BigDecimal!
  rewardsToDistribute: BigDecimal!
  startTime: BigInt!
}

input FeePeriod_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [FeePeriod_filter]
  feesClaimed: BigDecimal
  feesClaimed_gt: BigDecimal
  feesClaimed_gte: BigDecimal
  feesClaimed_in: [BigDecimal!]
  feesClaimed_lt: BigDecimal
  feesClaimed_lte: BigDecimal
  feesClaimed_not: BigDecimal
  feesClaimed_not_in: [BigDecimal!]
  feesToDistribute: BigDecimal
  feesToDistribute_gt: BigDecimal
  feesToDistribute_gte: BigDecimal
  feesToDistribute_in: [BigDecimal!]
  feesToDistribute_lt: BigDecimal
  feesToDistribute_lte: BigDecimal
  feesToDistribute_not: BigDecimal
  feesToDistribute_not_in: [BigDecimal!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [FeePeriod_filter]
  rewardsClaimed: BigDecimal
  rewardsClaimed_gt: BigDecimal
  rewardsClaimed_gte: BigDecimal
  rewardsClaimed_in: [BigDecimal!]
  rewardsClaimed_lt: BigDecimal
  rewardsClaimed_lte: BigDecimal
  rewardsClaimed_not: BigDecimal
  rewardsClaimed_not_in: [BigDecimal!]
  rewardsToDistribute: BigDecimal
  rewardsToDistribute_gt: BigDecimal
  rewardsToDistribute_gte: BigDecimal
  rewardsToDistribute_in: [BigDecimal!]
  rewardsToDistribute_lt: BigDecimal
  rewardsToDistribute_lte: BigDecimal
  rewardsToDistribute_not: BigDecimal
  rewardsToDistribute_not_in: [BigDecimal!]
  startTime: BigInt
  startTime_gt: BigInt
  startTime_gte: BigInt
  startTime_in: [BigInt!]
  startTime_lt: BigInt
  startTime_lte: BigInt
  startTime_not: BigInt
  startTime_not_in: [BigInt!]
}

enum FeePeriod_orderBy {
  feesClaimed
  feesToDistribute
  id
  rewardsClaimed
  rewardsToDistribute
  startTime
}

type FeeRate {
  """
  string representing the setting name
  """
  id: ID!

  """
  value of the setting
  """
  rate: BigDecimal!
  setting: String!

  """
  name of the synth this record applies to, if any
  """
  synth: String
}

input FeeRate_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [FeeRate_filter]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [FeeRate_filter]
  rate: BigDecimal
  rate_gt: BigDecimal
  rate_gte: BigDecimal
  rate_in: [BigDecimal!]
  rate_lt: BigDecimal
  rate_lte: BigDecimal
  rate_not: BigDecimal
  rate_not_in: [BigDecimal!]
  setting: String
  setting_contains: String
  setting_contains_nocase: String
  setting_ends_with: String
  setting_ends_with_nocase: String
  setting_gt: String
  setting_gte: String
  setting_in: [String!]
  setting_lt: String
  setting_lte: String
  setting_not: String
  setting_not_contains: String
  setting_not_contains_nocase: String
  setting_not_ends_with: String
  setting_not_ends_with_nocase: String
  setting_not_in: [String!]
  setting_not_starts_with: String
  setting_not_starts_with_nocase: String
  setting_starts_with: String
  setting_starts_with_nocase: String
  synth: String
  synth_contains: String
  synth_contains_nocase: String
  synth_ends_with: String
  synth_ends_with_nocase: String
  synth_gt: String
  synth_gte: String
  synth_in: [String!]
  synth_lt: String
  synth_lte: String
  synth_not: String
  synth_not_contains: String
  synth_not_contains_nocase: String
  synth_not_ends_with: String
  synth_not_ends_with_nocase: String
  synth_not_in: [String!]
  synth_not_starts_with: String
  synth_not_starts_with_nocase: String
  synth_starts_with: String
  synth_starts_with_nocase: String
}

enum FeeRate_orderBy {
  id
  rate
  setting
  synth
}

"""
Tracks this event from Synthetix.sol
"""
type FeesClaimed {
  account: Bytes!
  block: BigInt!
  id: ID!
  rewards: BigDecimal!
  timestamp: BigInt!
  value: BigDecimal!
}

input FeesClaimed_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  account: Bytes
  account_contains: Bytes
  account_gt: Bytes
  account_gte: Bytes
  account_in: [Bytes!]
  account_lt: Bytes
  account_lte: Bytes
  account_not: Bytes
  account_not_contains: Bytes
  account_not_in: [Bytes!]
  and: [FeesClaimed_filter]
  block: BigInt
  block_gt: BigInt
  block_gte: BigInt
  block_in: [BigInt!]
  block_lt: BigInt
  block_lte: BigInt
  block_not: BigInt
  block_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [FeesClaimed_filter]
  rewards: BigDecimal
  rewards_gt: BigDecimal
  rewards_gte: BigDecimal
  rewards_in: [BigDecimal!]
  rewards_lt: BigDecimal
  rewards_lte: BigDecimal
  rewards_not: BigDecimal
  rewards_not_in: [BigDecimal!]
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  value: BigDecimal
  value_gt: BigDecimal
  value_gte: BigDecimal
  value_in: [BigDecimal!]
  value_lt: BigDecimal
  value_lte: BigDecimal
  value_not: BigDecimal
  value_not_in: [BigDecimal!]
}

enum FeesClaimed_orderBy {
  account
  block
  id
  rewards
  timestamp
  value
}

type FuturesMarket {
  """
  Address of the market
  """
  id: ID!
}

input FuturesMarket_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [FuturesMarket_filter]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [FuturesMarket_filter]
}

enum FuturesMarket_orderBy {
  id
}

"""
we dont query this entity but only use it to store aggregate data we need during syncing
"""
type InversePricingInfo {
  """
  matching price point with long synth
  """
  entryPoint: BigDecimal!

  """
  whether or not this inverse synth has been frozen
  """
  frozen: Boolean!

  """
  Name of inverse synth. E.g. iETH
  """
  id: ID!

  """
  configured lower limit
  """
  lowerLimit: BigDecimal!

  """
  configured upper limit
  """
  upperLimit: BigDecimal!
}

input InversePricingInfo_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [InversePricingInfo_filter]
  entryPoint: BigDecimal
  entryPoint_gt: BigDecimal
  entryPoint_gte: BigDecimal
  entryPoint_in: [BigDecimal!]
  entryPoint_lt: BigDecimal
  entryPoint_lte: BigDecimal
  entryPoint_not: BigDecimal
  entryPoint_not_in: [BigDecimal!]
  frozen: Boolean
  frozen_in: [Boolean!]
  frozen_not: Boolean
  frozen_not_in: [Boolean!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  lowerLimit: BigDecimal
  lowerLimit_gt: BigDecimal
  lowerLimit_gte: BigDecimal
  lowerLimit_in: [BigDecimal!]
  lowerLimit_lt: BigDecimal
  lowerLimit_lte: BigDecimal
  lowerLimit_not: BigDecimal
  lowerLimit_not_in: [BigDecimal!]
  or: [InversePricingInfo_filter]
  upperLimit: BigDecimal
  upperLimit_gt: BigDecimal
  upperLimit_gte: BigDecimal
  upperLimit_in: [BigDecimal!]
  upperLimit_lt: BigDecimal
  upperLimit_lte: BigDecimal
  upperLimit_not: BigDecimal
  upperLimit_not_in: [BigDecimal!]
}

enum InversePricingInfo_orderBy {
  entryPoint
  frozen
  id
  lowerLimit
  upperLimit
}

"""
Tracks this event from various Synth.sol instances
"""
type Issued {
  account: Bytes!
  block: BigInt!
  gasPrice: BigInt!
  id: ID!
  source: String!
  timestamp: BigInt!
  value: BigDecimal!
}

input Issued_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  account: Bytes
  account_contains: Bytes
  account_gt: Bytes
  account_gte: Bytes
  account_in: [Bytes!]
  account_lt: Bytes
  account_lte: Bytes
  account_not: Bytes
  account_not_contains: Bytes
  account_not_in: [Bytes!]
  and: [Issued_filter]
  block: BigInt
  block_gt: BigInt
  block_gte: BigInt
  block_in: [BigInt!]
  block_lt: BigInt
  block_lte: BigInt
  block_not: BigInt
  block_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_gt: BigInt
  gasPrice_gte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_lt: BigInt
  gasPrice_lte: BigInt
  gasPrice_not: BigInt
  gasPrice_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [Issued_filter]
  source: String
  source_contains: String
  source_contains_nocase: String
  source_ends_with: String
  source_ends_with_nocase: String
  source_gt: String
  source_gte: String
  source_in: [String!]
  source_lt: String
  source_lte: String
  source_not: String
  source_not_contains: String
  source_not_contains_nocase: String
  source_not_ends_with: String
  source_not_ends_with_nocase: String
  source_not_in: [String!]
  source_not_starts_with: String
  source_not_starts_with_nocase: String
  source_starts_with: String
  source_starts_with_nocase: String
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  value: BigDecimal
  value_gt: BigDecimal
  value_gte: BigDecimal
  value_in: [BigDecimal!]
  value_lt: BigDecimal
  value_lte: BigDecimal
  value_not: BigDecimal
  value_not_in: [BigDecimal!]
}

enum Issued_orderBy {
  account
  block
  gasPrice
  id
  source
  timestamp
  value
}

"""
An individual Issuer
"""
type Issuer {
  id: ID!
}

input Issuer_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [Issuer_filter]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [Issuer_filter]
}

enum Issuer_orderBy {
  id
}

type LatestRate {
  """
  Address of the aggregator which produces current result
  """
  aggregator: Bytes!

  """
  Name of synth. E.g. sUSD
  """
  id: ID!

  """
  Synth USD rate
  """
  rate: BigDecimal!
}

input LatestRate_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  aggregator: Bytes
  aggregator_contains: Bytes
  aggregator_gt: Bytes
  aggregator_gte: Bytes
  aggregator_in: [Bytes!]
  aggregator_lt: Bytes
  aggregator_lte: Bytes
  aggregator_not: Bytes
  aggregator_not_contains: Bytes
  aggregator_not_in: [Bytes!]
  and: [LatestRate_filter]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [LatestRate_filter]
  rate: BigDecimal
  rate_gt: BigDecimal
  rate_gte: BigDecimal
  rate_in: [BigDecimal!]
  rate_lt: BigDecimal
  rate_lte: BigDecimal
  rate_not: BigDecimal
  rate_not_in: [BigDecimal!]
}

enum LatestRate_orderBy {
  aggregator
  id
  rate
}

"""
we dont query these entities but only use it to store aggregate data we need during syncing
"""
type LatestSynthBalance {
  account: String!
  address: Bytes!
  amount: BigDecimal!

  """
  account + synth address
  """
  id: ID!
  synth: Synth
  timestamp: BigInt!
}

input LatestSynthBalance_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  account: String
  account_contains: String
  account_contains_nocase: String
  account_ends_with: String
  account_ends_with_nocase: String
  account_gt: String
  account_gte: String
  account_in: [String!]
  account_lt: String
  account_lte: String
  account_not: String
  account_not_contains: String
  account_not_contains_nocase: String
  account_not_ends_with: String
  account_not_ends_with_nocase: String
  account_not_in: [String!]
  account_not_starts_with: String
  account_not_starts_with_nocase: String
  account_starts_with: String
  account_starts_with_nocase: String
  address: Bytes
  address_contains: Bytes
  address_gt: Bytes
  address_gte: Bytes
  address_in: [Bytes!]
  address_lt: Bytes
  address_lte: Bytes
  address_not: Bytes
  address_not_contains: Bytes
  address_not_in: [Bytes!]
  amount: BigDecimal
  amount_gt: BigDecimal
  amount_gte: BigDecimal
  amount_in: [BigDecimal!]
  amount_lt: BigDecimal
  amount_lte: BigDecimal
  amount_not: BigDecimal
  amount_not_in: [BigDecimal!]
  and: [LatestSynthBalance_filter]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [LatestSynthBalance_filter]
  synth: String
  synth_: Synth_filter
  synth_contains: String
  synth_contains_nocase: String
  synth_ends_with: String
  synth_ends_with_nocase: String
  synth_gt: String
  synth_gte: String
  synth_in: [String!]
  synth_lt: String
  synth_lte: String
  synth_not: String
  synth_not_contains: String
  synth_not_contains_nocase: String
  synth_not_ends_with: String
  synth_not_ends_with_nocase: String
  synth_not_in: [String!]
  synth_not_starts_with: String
  synth_not_starts_with_nocase: String
  synth_starts_with: String
  synth_starts_with_nocase: String
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
}

enum LatestSynthBalance_orderBy {
  account
  address
  amount
  id
  synth
  timestamp
}

type Loan {
  """
  the account receiving the loan
  """
  account: Bytes!

  """
  the amount of the loan
  """
  amount: BigDecimal!

  """
  the timestamp the loan was closed
  """
  closedAt: BigInt

  """
  the amount of collateral
  """
  collateralAmount: BigDecimal!

  """
  the currency of the collateralAmount
  """
  collateralMinted: String!

  """
  the timestamp the loan was created
  """
  createdAt: BigInt!

  """
  the currency of loan amount
  """
  currency: String!

  """
  whether the loan has any partial liquidations
  """
  hasPartialLiquidations: Boolean!

  """
  the loan id
  """
  id: ID!

  """
  is the loan still open?
  """
  isOpen: Boolean!

  """
  the transaction hash of the loan
  """
  txHash: String!
}

type LoanLiquidated {
  """
  the account that created the loan
  """
  account: Bytes!

  """
  the event tx hash plus event log index
  """
  id: ID!

  """
  the account that liquidated the loan
  """
  liquidator: Bytes!

  """
  the loan id
  """
  loanId: BigInt!

  """
  the timestamp the loan was liquidated
  """
  timestamp: BigInt!
}

input LoanLiquidated_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  account: Bytes
  account_contains: Bytes
  account_gt: Bytes
  account_gte: Bytes
  account_in: [Bytes!]
  account_lt: Bytes
  account_lte: Bytes
  account_not: Bytes
  account_not_contains: Bytes
  account_not_in: [Bytes!]
  and: [LoanLiquidated_filter]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  liquidator: Bytes
  liquidator_contains: Bytes
  liquidator_gt: Bytes
  liquidator_gte: Bytes
  liquidator_in: [Bytes!]
  liquidator_lt: Bytes
  liquidator_lte: Bytes
  liquidator_not: Bytes
  liquidator_not_contains: Bytes
  liquidator_not_in: [Bytes!]
  loanId: BigInt
  loanId_gt: BigInt
  loanId_gte: BigInt
  loanId_in: [BigInt!]
  loanId_lt: BigInt
  loanId_lte: BigInt
  loanId_not: BigInt
  loanId_not_in: [BigInt!]
  or: [LoanLiquidated_filter]
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
}

enum LoanLiquidated_orderBy {
  account
  id
  liquidator
  loanId
  timestamp
}

type LoanPartiallyLiquidated {
  """
  the account that created the loan
  """
  account: Bytes!

  """
  the event tx hash plus event log index
  """
  id: ID!

  """
  the amount partially liquidated
  """
  liquidatedAmount: BigDecimal!

  """
  the amount partially liquidated plus the liquidation fee
  """
  liquidatedCollateral: BigDecimal!

  """
  the account that partially liquidated the loan
  """
  liquidator: Bytes!

  """
  the loan id
  """
  loanId: BigInt!

  """
  the timestamp the loan was partially liquidated
  """
  timestamp: BigInt!
}

input LoanPartiallyLiquidated_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  account: Bytes
  account_contains: Bytes
  account_gt: Bytes
  account_gte: Bytes
  account_in: [Bytes!]
  account_lt: Bytes
  account_lte: Bytes
  account_not: Bytes
  account_not_contains: Bytes
  account_not_in: [Bytes!]
  and: [LoanPartiallyLiquidated_filter]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  liquidatedAmount: BigDecimal
  liquidatedAmount_gt: BigDecimal
  liquidatedAmount_gte: BigDecimal
  liquidatedAmount_in: [BigDecimal!]
  liquidatedAmount_lt: BigDecimal
  liquidatedAmount_lte: BigDecimal
  liquidatedAmount_not: BigDecimal
  liquidatedAmount_not_in: [BigDecimal!]
  liquidatedCollateral: BigDecimal
  liquidatedCollateral_gt: BigDecimal
  liquidatedCollateral_gte: BigDecimal
  liquidatedCollateral_in: [BigDecimal!]
  liquidatedCollateral_lt: BigDecimal
  liquidatedCollateral_lte: BigDecimal
  liquidatedCollateral_not: BigDecimal
  liquidatedCollateral_not_in: [BigDecimal!]
  liquidator: Bytes
  liquidator_contains: Bytes
  liquidator_gt: Bytes
  liquidator_gte: Bytes
  liquidator_in: [Bytes!]
  liquidator_lt: Bytes
  liquidator_lte: Bytes
  liquidator_not: Bytes
  liquidator_not_contains: Bytes
  liquidator_not_in: [Bytes!]
  loanId: BigInt
  loanId_gt: BigInt
  loanId_gte: BigInt
  loanId_in: [BigInt!]
  loanId_lt: BigInt
  loanId_lte: BigInt
  loanId_not: BigInt
  loanId_not_in: [BigInt!]
  or: [LoanPartiallyLiquidated_filter]
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
}

enum LoanPartiallyLiquidated_orderBy {
  account
  id
  liquidatedAmount
  liquidatedCollateral
  liquidator
  loanId
  timestamp
}

type LoanRepaid {
  """
  the account that created the loan
  """
  account: Bytes!

  """
  the event tx hash plus event log index
  """
  id: ID!

  """
  the loan id
  """
  loanId: BigInt!

  """
  the total amount of the loan after the repaid amount is accounted for
  """
  newLoanAmount: BigDecimal!

  """
  the amount of the loan that was repaid
  """
  repaidAmount: BigDecimal!

  """
  the timestamp the loan was partially or fully repaid
  """
  timestamp: BigInt!
}

input LoanRepaid_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  account: Bytes
  account_contains: Bytes
  account_gt: Bytes
  account_gte: Bytes
  account_in: [Bytes!]
  account_lt: Bytes
  account_lte: Bytes
  account_not: Bytes
  account_not_contains: Bytes
  account_not_in: [Bytes!]
  and: [LoanRepaid_filter]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  loanId: BigInt
  loanId_gt: BigInt
  loanId_gte: BigInt
  loanId_in: [BigInt!]
  loanId_lt: BigInt
  loanId_lte: BigInt
  loanId_not: BigInt
  loanId_not_in: [BigInt!]
  newLoanAmount: BigDecimal
  newLoanAmount_gt: BigDecimal
  newLoanAmount_gte: BigDecimal
  newLoanAmount_in: [BigDecimal!]
  newLoanAmount_lt: BigDecimal
  newLoanAmount_lte: BigDecimal
  newLoanAmount_not: BigDecimal
  newLoanAmount_not_in: [BigDecimal!]
  or: [LoanRepaid_filter]
  repaidAmount: BigDecimal
  repaidAmount_gt: BigDecimal
  repaidAmount_gte: BigDecimal
  repaidAmount_in: [BigDecimal!]
  repaidAmount_lt: BigDecimal
  repaidAmount_lte: BigDecimal
  repaidAmount_not: BigDecimal
  repaidAmount_not_in: [BigDecimal!]
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
}

enum LoanRepaid_orderBy {
  account
  id
  loanId
  newLoanAmount
  repaidAmount
  timestamp
}

input Loan_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  account: Bytes
  account_contains: Bytes
  account_gt: Bytes
  account_gte: Bytes
  account_in: [Bytes!]
  account_lt: Bytes
  account_lte: Bytes
  account_not: Bytes
  account_not_contains: Bytes
  account_not_in: [Bytes!]
  amount: BigDecimal
  amount_gt: BigDecimal
  amount_gte: BigDecimal
  amount_in: [BigDecimal!]
  amount_lt: BigDecimal
  amount_lte: BigDecimal
  amount_not: BigDecimal
  amount_not_in: [BigDecimal!]
  and: [Loan_filter]
  closedAt: BigInt
  closedAt_gt: BigInt
  closedAt_gte: BigInt
  closedAt_in: [BigInt!]
  closedAt_lt: BigInt
  closedAt_lte: BigInt
  closedAt_not: BigInt
  closedAt_not_in: [BigInt!]
  collateralAmount: BigDecimal
  collateralAmount_gt: BigDecimal
  collateralAmount_gte: BigDecimal
  collateralAmount_in: [BigDecimal!]
  collateralAmount_lt: BigDecimal
  collateralAmount_lte: BigDecimal
  collateralAmount_not: BigDecimal
  collateralAmount_not_in: [BigDecimal!]
  collateralMinted: String
  collateralMinted_contains: String
  collateralMinted_contains_nocase: String
  collateralMinted_ends_with: String
  collateralMinted_ends_with_nocase: String
  collateralMinted_gt: String
  collateralMinted_gte: String
  collateralMinted_in: [String!]
  collateralMinted_lt: String
  collateralMinted_lte: String
  collateralMinted_not: String
  collateralMinted_not_contains: String
  collateralMinted_not_contains_nocase: String
  collateralMinted_not_ends_with: String
  collateralMinted_not_ends_with_nocase: String
  collateralMinted_not_in: [String!]
  collateralMinted_not_starts_with: String
  collateralMinted_not_starts_with_nocase: String
  collateralMinted_starts_with: String
  collateralMinted_starts_with_nocase: String
  createdAt: BigInt
  createdAt_gt: BigInt
  createdAt_gte: BigInt
  createdAt_in: [BigInt!]
  createdAt_lt: BigInt
  createdAt_lte: BigInt
  createdAt_not: BigInt
  createdAt_not_in: [BigInt!]
  currency: String
  currency_contains: String
  currency_contains_nocase: String
  currency_ends_with: String
  currency_ends_with_nocase: String
  currency_gt: String
  currency_gte: String
  currency_in: [String!]
  currency_lt: String
  currency_lte: String
  currency_not: String
  currency_not_contains: String
  currency_not_contains_nocase: String
  currency_not_ends_with: String
  currency_not_ends_with_nocase: String
  currency_not_in: [String!]
  currency_not_starts_with: String
  currency_not_starts_with_nocase: String
  currency_starts_with: String
  currency_starts_with_nocase: String
  hasPartialLiquidations: Boolean
  hasPartialLiquidations_in: [Boolean!]
  hasPartialLiquidations_not: Boolean
  hasPartialLiquidations_not_in: [Boolean!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  isOpen: Boolean
  isOpen_in: [Boolean!]
  isOpen_not: Boolean
  isOpen_not_in: [Boolean!]
  or: [Loan_filter]
  txHash: String
  txHash_contains: String
  txHash_contains_nocase: String
  txHash_ends_with: String
  txHash_ends_with_nocase: String
  txHash_gt: String
  txHash_gte: String
  txHash_in: [String!]
  txHash_lt: String
  txHash_lte: String
  txHash_not: String
  txHash_not_contains: String
  txHash_not_contains_nocase: String
  txHash_not_ends_with: String
  txHash_not_ends_with_nocase: String
  txHash_not_in: [String!]
  txHash_not_starts_with: String
  txHash_not_starts_with_nocase: String
  txHash_starts_with: String
  txHash_starts_with_nocase: String
}

enum Loan_orderBy {
  account
  amount
  closedAt
  collateralAmount
  collateralMinted
  createdAt
  currency
  hasPartialLiquidations
  id
  isOpen
  txHash
}

"""
Defines the order direction, either ascending or descending
"""
enum OrderDirection {
  asc
  desc
}

type Query {
  """
  Access to subgraph metadata
  """
  _meta(block: Block_height): _Meta_
  accountFlaggedForLiquidation(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AccountFlaggedForLiquidation
  accountFlaggedForLiquidations(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: AccountFlaggedForLiquidation_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: AccountFlaggedForLiquidation_filter
  ): [AccountFlaggedForLiquidation!]!
  accountLiquidated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AccountLiquidated
  accountLiquidateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: AccountLiquidated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: AccountLiquidated_filter
  ): [AccountLiquidated!]!
  accountRemovedFromLiquidation(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AccountRemovedFromLiquidation
  accountRemovedFromLiquidations(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: AccountRemovedFromLiquidation_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: AccountRemovedFromLiquidation_filter
  ): [AccountRemovedFromLiquidation!]!
  activeStaker(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ActiveStaker
  activeStakers(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ActiveStaker_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ActiveStaker_filter
  ): [ActiveStaker!]!
  atomicSynthExchange(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AtomicSynthExchange
  atomicSynthExchanges(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: AtomicSynthExchange_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: AtomicSynthExchange_filter
  ): [AtomicSynthExchange!]!
  burned(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Burned
  burneds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Burned_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Burned_filter
  ): [Burned!]!
  candle(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Candle
  candles(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Candle_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Candle_filter
  ): [Candle!]!
  collateralDeposited(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CollateralDeposited
  collateralDepositeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: CollateralDeposited_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: CollateralDeposited_filter
  ): [CollateralDeposited!]!
  collateralWithdrawn(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CollateralWithdrawn
  collateralWithdrawns(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: CollateralWithdrawn_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: CollateralWithdrawn_filter
  ): [CollateralWithdrawn!]!
  dailyBurned(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DailyBurned
  dailyBurneds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: DailyBurned_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: DailyBurned_filter
  ): [DailyBurned!]!
  dailyCandle(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DailyCandle
  dailyCandles(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: DailyCandle_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: DailyCandle_filter
  ): [DailyCandle!]!
  dailyExchangePartner(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DailyExchangePartner
  dailyExchangePartners(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: DailyExchangePartner_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: DailyExchangePartner_filter
  ): [DailyExchangePartner!]!
  dailyIssued(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DailyIssued
  dailyIssueds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: DailyIssued_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: DailyIssued_filter
  ): [DailyIssued!]!
  debtSnapshot(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DebtSnapshot
  debtSnapshots(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: DebtSnapshot_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: DebtSnapshot_filter
  ): [DebtSnapshot!]!
  debtState(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DebtState
  debtStates(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: DebtState_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: DebtState_filter
  ): [DebtState!]!
  delegatedWallet(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DelegatedWallet
  delegatedWallets(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: DelegatedWallet_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: DelegatedWallet_filter
  ): [DelegatedWallet!]!
  exchangeEntryAppended(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ExchangeEntryAppended
  exchangeEntryAppendeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ExchangeEntryAppended_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ExchangeEntryAppended_filter
  ): [ExchangeEntryAppended!]!
  exchangeEntrySettled(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ExchangeEntrySettled
  exchangeEntrySettleds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ExchangeEntrySettled_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ExchangeEntrySettled_filter
  ): [ExchangeEntrySettled!]!
  exchangeFee(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ExchangeFee
  exchangeFees(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ExchangeFee_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ExchangeFee_filter
  ): [ExchangeFee!]!
  exchangePartner(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ExchangePartner
  exchangePartners(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ExchangePartner_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ExchangePartner_filter
  ): [ExchangePartner!]!
  exchangeRebate(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ExchangeRebate
  exchangeRebates(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ExchangeRebate_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ExchangeRebate_filter
  ): [ExchangeRebate!]!
  exchangeReclaim(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ExchangeReclaim
  exchangeReclaims(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ExchangeReclaim_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ExchangeReclaim_filter
  ): [ExchangeReclaim!]!
  exchanger(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Exchanger
  exchangers(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Exchanger_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Exchanger_filter
  ): [Exchanger!]!
  feePeriod(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): FeePeriod
  feePeriods(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: FeePeriod_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: FeePeriod_filter
  ): [FeePeriod!]!
  feeRate(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): FeeRate
  feeRates(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: FeeRate_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: FeeRate_filter
  ): [FeeRate!]!
  feesClaimed(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): FeesClaimed
  feesClaimeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: FeesClaimed_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: FeesClaimed_filter
  ): [FeesClaimed!]!
  futuresMarket(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): FuturesMarket
  futuresMarkets(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: FuturesMarket_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: FuturesMarket_filter
  ): [FuturesMarket!]!
  inversePricingInfo(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): InversePricingInfo
  inversePricingInfos(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: InversePricingInfo_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: InversePricingInfo_filter
  ): [InversePricingInfo!]!
  issued(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Issued
  issueds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Issued_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Issued_filter
  ): [Issued!]!
  issuer(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Issuer
  issuers(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Issuer_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Issuer_filter
  ): [Issuer!]!
  latestRate(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LatestRate
  latestRates(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LatestRate_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LatestRate_filter
  ): [LatestRate!]!
  latestSynthBalance(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LatestSynthBalance
  latestSynthBalances(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LatestSynthBalance_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LatestSynthBalance_filter
  ): [LatestSynthBalance!]!
  loan(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Loan
  loanLiquidated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LoanLiquidated
  loanLiquidateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LoanLiquidated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LoanLiquidated_filter
  ): [LoanLiquidated!]!
  loanPartiallyLiquidated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LoanPartiallyLiquidated
  loanPartiallyLiquidateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LoanPartiallyLiquidated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LoanPartiallyLiquidated_filter
  ): [LoanPartiallyLiquidated!]!
  loanRepaid(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LoanRepaid
  loanRepaids(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LoanRepaid_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LoanRepaid_filter
  ): [LoanRepaid!]!
  loans(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Loan_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Loan_filter
  ): [Loan!]!
  rateUpdate(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RateUpdate
  rateUpdates(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: RateUpdate_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: RateUpdate_filter
  ): [RateUpdate!]!
  rewardEscrowHolder(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RewardEscrowHolder
  rewardEscrowHolders(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: RewardEscrowHolder_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: RewardEscrowHolder_filter
  ): [RewardEscrowHolder!]!
  short(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Short
  shortCollateralChange(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ShortCollateralChange
  shortCollateralChanges(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ShortCollateralChange_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ShortCollateralChange_filter
  ): [ShortCollateralChange!]!
  shortContract(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ShortContract
  shortContractUpdate(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ShortContractUpdate
  shortContractUpdates(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ShortContractUpdate_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ShortContractUpdate_filter
  ): [ShortContractUpdate!]!
  shortContracts(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ShortContract_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ShortContract_filter
  ): [ShortContract!]!
  shortLiquidation(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ShortLiquidation
  shortLiquidations(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ShortLiquidation_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ShortLiquidation_filter
  ): [ShortLiquidation!]!
  shortLoanChange(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ShortLoanChange
  shortLoanChanges(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ShortLoanChange_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ShortLoanChange_filter
  ): [ShortLoanChange!]!
  shorts(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Short_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Short_filter
  ): [Short!]!
  snxholder(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SNXHolder
  snxholders(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: SNXHolder_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: SNXHolder_filter
  ): [SNXHolder!]!
  synth(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Synth
  synthBalance(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SynthBalance
  synthBalances(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: SynthBalance_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: SynthBalance_filter
  ): [SynthBalance!]!
  synthByCurrencyKey(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SynthByCurrencyKey
  synthByCurrencyKeys(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: SynthByCurrencyKey_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: SynthByCurrencyKey_filter
  ): [SynthByCurrencyKey!]!
  synthExchange(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SynthExchange
  synthExchanges(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: SynthExchange_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: SynthExchange_filter
  ): [SynthExchange!]!
  synthetix(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Synthetix
  synthetixes(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Synthetix_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Synthetix_filter
  ): [Synthetix!]!
  synths(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Synth_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Synth_filter
  ): [Synth!]!
  systemSetting(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SystemSetting
  systemSettings(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: SystemSetting_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: SystemSetting_filter
  ): [SystemSetting!]!
  temporaryExchangePartnerTracker(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TemporaryExchangePartnerTracker
  temporaryExchangePartnerTrackers(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: TemporaryExchangePartnerTracker_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: TemporaryExchangePartnerTracker_filter
  ): [TemporaryExchangePartnerTracker!]!
  total(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Total
  totalActiveStaker(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TotalActiveStaker
  totalActiveStakers(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: TotalActiveStaker_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: TotalActiveStaker_filter
  ): [TotalActiveStaker!]!
  totalDailyActiveStaker(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TotalDailyActiveStaker
  totalDailyActiveStakers(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: TotalDailyActiveStaker_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: TotalDailyActiveStaker_filter
  ): [TotalDailyActiveStaker!]!
  totals(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Total_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Total_filter
  ): [Total!]!
  wrapper(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Wrapper
  wrapperBurn(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): WrapperBurn
  wrapperBurns(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: WrapperBurn_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: WrapperBurn_filter
  ): [WrapperBurn!]!
  wrapperMint(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): WrapperMint
  wrapperMints(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: WrapperMint_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: WrapperMint_filter
  ): [WrapperMint!]!
  wrappers(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Wrapper_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Wrapper_filter
  ): [Wrapper!]!
}

"""
Latest Rates over time
"""
type RateUpdate {
  """
  the block which this rate was recorded
  """
  block: BigInt!

  """
  currencyKey for which this this rate update applies
  """
  currencyKey: Bytes!

  """
  <transaction hash>-<currency key>
  """
  id: ID!

  """
  the rate recorded at this timestamp
  """
  rate: BigDecimal!

  """
  currencyKey expressed as a string
  """
  synth: String!

  """
  timestamp of the block in which the rate was recorded
  """
  timestamp: BigInt!
}

input RateUpdate_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [RateUpdate_filter]
  block: BigInt
  block_gt: BigInt
  block_gte: BigInt
  block_in: [BigInt!]
  block_lt: BigInt
  block_lte: BigInt
  block_not: BigInt
  block_not_in: [BigInt!]
  currencyKey: Bytes
  currencyKey_contains: Bytes
  currencyKey_gt: Bytes
  currencyKey_gte: Bytes
  currencyKey_in: [Bytes!]
  currencyKey_lt: Bytes
  currencyKey_lte: Bytes
  currencyKey_not: Bytes
  currencyKey_not_contains: Bytes
  currencyKey_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [RateUpdate_filter]
  rate: BigDecimal
  rate_gt: BigDecimal
  rate_gte: BigDecimal
  rate_in: [BigDecimal!]
  rate_lt: BigDecimal
  rate_lte: BigDecimal
  rate_not: BigDecimal
  rate_not_in: [BigDecimal!]
  synth: String
  synth_contains: String
  synth_contains_nocase: String
  synth_ends_with: String
  synth_ends_with_nocase: String
  synth_gt: String
  synth_gte: String
  synth_in: [String!]
  synth_lt: String
  synth_lte: String
  synth_not: String
  synth_not_contains: String
  synth_not_contains_nocase: String
  synth_not_ends_with: String
  synth_not_ends_with_nocase: String
  synth_not_in: [String!]
  synth_not_starts_with: String
  synth_not_starts_with_nocase: String
  synth_starts_with: String
  synth_starts_with_nocase: String
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
}

enum RateUpdate_orderBy {
  block
  currencyKey
  id
  rate
  synth
  timestamp
}

type RewardEscrowHolder {
  """
  amount of tokens remaining to be claimed from the escrow
  """
  balanceOf: BigDecimal!

  """
  address which holds a rewardescrow
  """
  id: ID!

  """
  amount of SNX claimed from the escrow
  """
  vestedBalanceOf: BigDecimal!
}

input RewardEscrowHolder_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [RewardEscrowHolder_filter]
  balanceOf: BigDecimal
  balanceOf_gt: BigDecimal
  balanceOf_gte: BigDecimal
  balanceOf_in: [BigDecimal!]
  balanceOf_lt: BigDecimal
  balanceOf_lte: BigDecimal
  balanceOf_not: BigDecimal
  balanceOf_not_in: [BigDecimal!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [RewardEscrowHolder_filter]
  vestedBalanceOf: BigDecimal
  vestedBalanceOf_gt: BigDecimal
  vestedBalanceOf_gte: BigDecimal
  vestedBalanceOf_in: [BigDecimal!]
  vestedBalanceOf_lt: BigDecimal
  vestedBalanceOf_lte: BigDecimal
  vestedBalanceOf_not: BigDecimal
  vestedBalanceOf_not_in: [BigDecimal!]
}

enum RewardEscrowHolder_orderBy {
  balanceOf
  id
  vestedBalanceOf
}

"""
An individual SNX holder (always overridden with their latest information)
"""
type SNXHolder {
  """
  current SNX balance of the holder
  """
  balanceOf: BigDecimal

  """
  last block where an event happened
  """
  block: BigInt!

  """
  number of claims performed
  """
  claims: BigInt

  """
  SNX which is being used for collateral as of last event and cannot be spent
  """
  collateral: BigDecimal
  debtEntryAtIndex: BigInt

  """
  address of holder
  """
  id: ID!
  initialDebtOwnership: BigInt

  """
  number of mints performed
  """
  mints: BigInt

  """
  last time where an event happened
  """
  timestamp: BigInt!

  """
  SNX which can be spent as of last event
  """
  transferable: BigDecimal
}

input SNXHolder_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [SNXHolder_filter]
  balanceOf: BigDecimal
  balanceOf_gt: BigDecimal
  balanceOf_gte: BigDecimal
  balanceOf_in: [BigDecimal!]
  balanceOf_lt: BigDecimal
  balanceOf_lte: BigDecimal
  balanceOf_not: BigDecimal
  balanceOf_not_in: [BigDecimal!]
  block: BigInt
  block_gt: BigInt
  block_gte: BigInt
  block_in: [BigInt!]
  block_lt: BigInt
  block_lte: BigInt
  block_not: BigInt
  block_not_in: [BigInt!]
  claims: BigInt
  claims_gt: BigInt
  claims_gte: BigInt
  claims_in: [BigInt!]
  claims_lt: BigInt
  claims_lte: BigInt
  claims_not: BigInt
  claims_not_in: [BigInt!]
  collateral: BigDecimal
  collateral_gt: BigDecimal
  collateral_gte: BigDecimal
  collateral_in: [BigDecimal!]
  collateral_lt: BigDecimal
  collateral_lte: BigDecimal
  collateral_not: BigDecimal
  collateral_not_in: [BigDecimal!]
  debtEntryAtIndex: BigInt
  debtEntryAtIndex_gt: BigInt
  debtEntryAtIndex_gte: BigInt
  debtEntryAtIndex_in: [BigInt!]
  debtEntryAtIndex_lt: BigInt
  debtEntryAtIndex_lte: BigInt
  debtEntryAtIndex_not: BigInt
  debtEntryAtIndex_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  initialDebtOwnership: BigInt
  initialDebtOwnership_gt: BigInt
  initialDebtOwnership_gte: BigInt
  initialDebtOwnership_in: [BigInt!]
  initialDebtOwnership_lt: BigInt
  initialDebtOwnership_lte: BigInt
  initialDebtOwnership_not: BigInt
  initialDebtOwnership_not_in: [BigInt!]
  mints: BigInt
  mints_gt: BigInt
  mints_gte: BigInt
  mints_in: [BigInt!]
  mints_lt: BigInt
  mints_lte: BigInt
  mints_not: BigInt
  mints_not_in: [BigInt!]
  or: [SNXHolder_filter]
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  transferable: BigDecimal
  transferable_gt: BigDecimal
  transferable_gte: BigDecimal
  transferable_in: [BigDecimal!]
  transferable_lt: BigDecimal
  transferable_lte: BigDecimal
  transferable_not: BigDecimal
  transferable_not_in: [BigDecimal!]
}

enum SNXHolder_orderBy {
  balanceOf
  block
  claims
  collateral
  debtEntryAtIndex
  id
  initialDebtOwnership
  mints
  timestamp
  transferable
}

type Short {
  """
  the account that created the short
  """
  account: Bytes!

  """
  the timestamp the accrued interest was most recently updated
  """
  accruedInterestLastUpdateTimestamp: BigInt!

  """
  the timestamp the short was closed
  """
  closedAt: BigInt

  """
  collateral deposits and withdrawals that have been made on the short
  """
  collateralChanges(
    first: Int = 100
    orderBy: ShortCollateralChange_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: ShortCollateralChange_filter
  ): [ShortCollateralChange!]

  """
  the type of collateral locked - sUSD, ETH, renBTC
  """
  collateralLocked: Bytes!

  """
  the amount of collateral locked in the short
  """
  collateralLockedAmount: BigDecimal!

  """
  contract level info for the short position
  """
  contractData: ShortContract!

  """
  the timestamp the short was created
  """
  createdAt: BigInt!

  """
  the block the short was created at
  """
  createdAtBlock: BigInt!

  """
  the short id
  """
  id: ID!

  """
  is the short still open?
  """
  isOpen: Boolean!

  """
  liquidations that have been made on the short
  """
  liquidations(
    first: Int = 100
    orderBy: ShortLiquidation_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: ShortLiquidation_filter
  ): [ShortLiquidation!]

  """
  loan changes that have been made on the short - increasing or decreasing the short position
  """
  loanChanges(
    first: Int = 100
    orderBy: ShortLoanChange_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: ShortLoanChange_filter
  ): [ShortLoanChange!]!

  """
  the denomination of the loan repayment - sETH, sBTC
  """
  synthBorrowed: Bytes!

  """
  the amount owed denominated in the loan repayment synth
  """
  synthBorrowedAmount: BigDecimal!

  """
  the transaction hash of the short
  """
  txHash: String!
}

type ShortCollateralChange {
  """
  the amount of collateral deposited or withdrawn
  """
  amount: BigDecimal!

  """
  the block the collateral was changed
  """
  blockNumber: BigInt!

  """
  the total amount of collateral after the deposit or withdrawal is included
  """
  collateralAfter: BigDecimal!

  """
  the event tx hash plus event log index
  """
  id: ID!

  """
  denotes if the event was a deposit (true) or withdrawal (false)
  """
  isDeposit: Boolean!

  """
  the respective short
  """
  short: Short!

  """
  the timestamp collateral was deposited or withdrawn
  """
  timestamp: BigInt!
}

input ShortCollateralChange_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  amount: BigDecimal
  amount_gt: BigDecimal
  amount_gte: BigDecimal
  amount_in: [BigDecimal!]
  amount_lt: BigDecimal
  amount_lte: BigDecimal
  amount_not: BigDecimal
  amount_not_in: [BigDecimal!]
  and: [ShortCollateralChange_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  collateralAfter: BigDecimal
  collateralAfter_gt: BigDecimal
  collateralAfter_gte: BigDecimal
  collateralAfter_in: [BigDecimal!]
  collateralAfter_lt: BigDecimal
  collateralAfter_lte: BigDecimal
  collateralAfter_not: BigDecimal
  collateralAfter_not_in: [BigDecimal!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  isDeposit: Boolean
  isDeposit_in: [Boolean!]
  isDeposit_not: Boolean
  isDeposit_not_in: [Boolean!]
  or: [ShortCollateralChange_filter]
  short: String
  short_: Short_filter
  short_contains: String
  short_contains_nocase: String
  short_ends_with: String
  short_ends_with_nocase: String
  short_gt: String
  short_gte: String
  short_in: [String!]
  short_lt: String
  short_lte: String
  short_not: String
  short_not_contains: String
  short_not_contains_nocase: String
  short_not_ends_with: String
  short_not_ends_with_nocase: String
  short_not_in: [String!]
  short_not_starts_with: String
  short_not_starts_with_nocase: String
  short_starts_with: String
  short_starts_with_nocase: String
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
}

enum ShortCollateralChange_orderBy {
  amount
  blockNumber
  collateralAfter
  id
  isDeposit
  short
  timestamp
}

type ShortContract {
  """
  a boolean that prevents new loans on the contract when false
  """
  canOpenLoans: Boolean!

  """
  a list of changes to contract level data
  """
  contractUpdates(
    first: Int = 100
    orderBy: ShortContractUpdate_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: ShortContractUpdate_filter
  ): [ShortContractUpdate!]

  """
  the address of the shorting contract
  """
  id: ID!

  """
  Time in seconds that a user must wait between interacting with a loan. Provides front running and flash loan protection.
  """
  interactionDelay: BigInt!

  """
  the fee for issuing a short
  """
  issueFeeRate: BigDecimal!

  """
  the manager is a contract that ties the shorting contract in with the rest of the Synthetix protocol
  """
  manager: Bytes!

  """
  the max number of loans per account
  """
  maxLoansPerAccount: BigInt!

  """
  the minimum collateral required to open a position
  """
  minCollateral: BigDecimal!

  """
  the min c-ratio for borrowers below which they can be liquidated
  """
  minCratio: BigInt!

  """
  a list of shorts attached to each contract
  """
  shorts(
    first: Int = 100
    orderBy: Short_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: Short_filter
  ): [Short!]
}

type ShortContractUpdate {
  """
  the block the short contract was udpated at
  """
  blockNumber: BigInt!

  """
  the respective short contract
  """
  contractData: ShortContract!

  """
  the field that was changed
  """
  field: String!

  """
  the event tx hash plus event log index
  """
  id: ID!

  """
  the timestamp of the contract update event
  """
  timestamp: BigInt!

  """
  the new value of the field in string format
  """
  value: String!
}

input ShortContractUpdate_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [ShortContractUpdate_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  contractData: String
  contractData_: ShortContract_filter
  contractData_contains: String
  contractData_contains_nocase: String
  contractData_ends_with: String
  contractData_ends_with_nocase: String
  contractData_gt: String
  contractData_gte: String
  contractData_in: [String!]
  contractData_lt: String
  contractData_lte: String
  contractData_not: String
  contractData_not_contains: String
  contractData_not_contains_nocase: String
  contractData_not_ends_with: String
  contractData_not_ends_with_nocase: String
  contractData_not_in: [String!]
  contractData_not_starts_with: String
  contractData_not_starts_with_nocase: String
  contractData_starts_with: String
  contractData_starts_with_nocase: String
  field: String
  field_contains: String
  field_contains_nocase: String
  field_ends_with: String
  field_ends_with_nocase: String
  field_gt: String
  field_gte: String
  field_in: [String!]
  field_lt: String
  field_lte: String
  field_not: String
  field_not_contains: String
  field_not_contains_nocase: String
  field_not_ends_with: String
  field_not_ends_with_nocase: String
  field_not_in: [String!]
  field_not_starts_with: String
  field_not_starts_with_nocase: String
  field_starts_with: String
  field_starts_with_nocase: String
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [ShortContractUpdate_filter]
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  value: String
  value_contains: String
  value_contains_nocase: String
  value_ends_with: String
  value_ends_with_nocase: String
  value_gt: String
  value_gte: String
  value_in: [String!]
  value_lt: String
  value_lte: String
  value_not: String
  value_not_contains: String
  value_not_contains_nocase: String
  value_not_ends_with: String
  value_not_ends_with_nocase: String
  value_not_in: [String!]
  value_not_starts_with: String
  value_not_starts_with_nocase: String
  value_starts_with: String
  value_starts_with_nocase: String
}

enum ShortContractUpdate_orderBy {
  blockNumber
  contractData
  field
  id
  timestamp
  value
}

input ShortContract_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [ShortContract_filter]
  canOpenLoans: Boolean
  canOpenLoans_in: [Boolean!]
  canOpenLoans_not: Boolean
  canOpenLoans_not_in: [Boolean!]
  contractUpdates_: ShortContractUpdate_filter
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  interactionDelay: BigInt
  interactionDelay_gt: BigInt
  interactionDelay_gte: BigInt
  interactionDelay_in: [BigInt!]
  interactionDelay_lt: BigInt
  interactionDelay_lte: BigInt
  interactionDelay_not: BigInt
  interactionDelay_not_in: [BigInt!]
  issueFeeRate: BigDecimal
  issueFeeRate_gt: BigDecimal
  issueFeeRate_gte: BigDecimal
  issueFeeRate_in: [BigDecimal!]
  issueFeeRate_lt: BigDecimal
  issueFeeRate_lte: BigDecimal
  issueFeeRate_not: BigDecimal
  issueFeeRate_not_in: [BigDecimal!]
  manager: Bytes
  manager_contains: Bytes
  manager_gt: Bytes
  manager_gte: Bytes
  manager_in: [Bytes!]
  manager_lt: Bytes
  manager_lte: Bytes
  manager_not: Bytes
  manager_not_contains: Bytes
  manager_not_in: [Bytes!]
  maxLoansPerAccount: BigInt
  maxLoansPerAccount_gt: BigInt
  maxLoansPerAccount_gte: BigInt
  maxLoansPerAccount_in: [BigInt!]
  maxLoansPerAccount_lt: BigInt
  maxLoansPerAccount_lte: BigInt
  maxLoansPerAccount_not: BigInt
  maxLoansPerAccount_not_in: [BigInt!]
  minCollateral: BigDecimal
  minCollateral_gt: BigDecimal
  minCollateral_gte: BigDecimal
  minCollateral_in: [BigDecimal!]
  minCollateral_lt: BigDecimal
  minCollateral_lte: BigDecimal
  minCollateral_not: BigDecimal
  minCollateral_not_in: [BigDecimal!]
  minCratio: BigInt
  minCratio_gt: BigInt
  minCratio_gte: BigInt
  minCratio_in: [BigInt!]
  minCratio_lt: BigInt
  minCratio_lte: BigInt
  minCratio_not: BigInt
  minCratio_not_in: [BigInt!]
  or: [ShortContract_filter]
  shorts_: Short_filter
}

enum ShortContract_orderBy {
  canOpenLoans
  contractUpdates
  id
  interactionDelay
  issueFeeRate
  manager
  maxLoansPerAccount
  minCollateral
  minCratio
  shorts
}

type ShortLiquidation {
  """
  the block of the liquidation event
  """
  blockNumber: BigInt!

  """
  the event tx hash plus event log index
  """
  id: ID!

  """
  determines if the
  """
  isClosed: Boolean!

  """
  the amount of the loan that was burned
  """
  liquidatedAmount: BigDecimal!

  """
  the amount of the collateral that was taken away from the short owner
  """
  liquidatedCollateral: BigDecimal!

  """
  the account that liquidated the loan
  """
  liquidator: Bytes!

  """
  the respective short
  """
  short: Short!

  """
  the timestamp of the loan liquidation event
  """
  timestamp: BigInt!
}

input ShortLiquidation_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [ShortLiquidation_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  isClosed: Boolean
  isClosed_in: [Boolean!]
  isClosed_not: Boolean
  isClosed_not_in: [Boolean!]
  liquidatedAmount: BigDecimal
  liquidatedAmount_gt: BigDecimal
  liquidatedAmount_gte: BigDecimal
  liquidatedAmount_in: [BigDecimal!]
  liquidatedAmount_lt: BigDecimal
  liquidatedAmount_lte: BigDecimal
  liquidatedAmount_not: BigDecimal
  liquidatedAmount_not_in: [BigDecimal!]
  liquidatedCollateral: BigDecimal
  liquidatedCollateral_gt: BigDecimal
  liquidatedCollateral_gte: BigDecimal
  liquidatedCollateral_in: [BigDecimal!]
  liquidatedCollateral_lt: BigDecimal
  liquidatedCollateral_lte: BigDecimal
  liquidatedCollateral_not: BigDecimal
  liquidatedCollateral_not_in: [BigDecimal!]
  liquidator: Bytes
  liquidator_contains: Bytes
  liquidator_gt: Bytes
  liquidator_gte: Bytes
  liquidator_in: [Bytes!]
  liquidator_lt: Bytes
  liquidator_lte: Bytes
  liquidator_not: Bytes
  liquidator_not_contains: Bytes
  liquidator_not_in: [Bytes!]
  or: [ShortLiquidation_filter]
  short: String
  short_: Short_filter
  short_contains: String
  short_contains_nocase: String
  short_ends_with: String
  short_ends_with_nocase: String
  short_gt: String
  short_gte: String
  short_in: [String!]
  short_lt: String
  short_lte: String
  short_not: String
  short_not_contains: String
  short_not_contains_nocase: String
  short_not_ends_with: String
  short_not_ends_with_nocase: String
  short_not_in: [String!]
  short_not_starts_with: String
  short_not_starts_with_nocase: String
  short_starts_with: String
  short_starts_with_nocase: String
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
}

enum ShortLiquidation_orderBy {
  blockNumber
  id
  isClosed
  liquidatedAmount
  liquidatedCollateral
  liquidator
  short
  timestamp
}

type ShortLoanChange {
  """
  the amount of loan repaid or increased
  """
  amount: BigDecimal!

  """
  the block the short loan was changed
  """
  blockNumber: BigInt!

  """
  the event tx hash plus event log index
  """
  id: ID!

  """
  denotes if the event was a repayment (true) or an increase of the loan (false)
  """
  isRepayment: Boolean!

  """
  the total amount of loan due after the repayment or increase is included
  """
  loanAfter: BigDecimal!

  """
  the price of the repaid synth in dollars
  """
  rate: BigDecimal!

  """
  the respective short
  """
  short: Short!

  """
  the timestamp of the loan repayment or increase
  """
  timestamp: BigInt!
}

input ShortLoanChange_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  amount: BigDecimal
  amount_gt: BigDecimal
  amount_gte: BigDecimal
  amount_in: [BigDecimal!]
  amount_lt: BigDecimal
  amount_lte: BigDecimal
  amount_not: BigDecimal
  amount_not_in: [BigDecimal!]
  and: [ShortLoanChange_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  isRepayment: Boolean
  isRepayment_in: [Boolean!]
  isRepayment_not: Boolean
  isRepayment_not_in: [Boolean!]
  loanAfter: BigDecimal
  loanAfter_gt: BigDecimal
  loanAfter_gte: BigDecimal
  loanAfter_in: [BigDecimal!]
  loanAfter_lt: BigDecimal
  loanAfter_lte: BigDecimal
  loanAfter_not: BigDecimal
  loanAfter_not_in: [BigDecimal!]
  or: [ShortLoanChange_filter]
  rate: BigDecimal
  rate_gt: BigDecimal
  rate_gte: BigDecimal
  rate_in: [BigDecimal!]
  rate_lt: BigDecimal
  rate_lte: BigDecimal
  rate_not: BigDecimal
  rate_not_in: [BigDecimal!]
  short: String
  short_: Short_filter
  short_contains: String
  short_contains_nocase: String
  short_ends_with: String
  short_ends_with_nocase: String
  short_gt: String
  short_gte: String
  short_in: [String!]
  short_lt: String
  short_lte: String
  short_not: String
  short_not_contains: String
  short_not_contains_nocase: String
  short_not_ends_with: String
  short_not_ends_with_nocase: String
  short_not_in: [String!]
  short_not_starts_with: String
  short_not_starts_with_nocase: String
  short_starts_with: String
  short_starts_with_nocase: String
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
}

enum ShortLoanChange_orderBy {
  amount
  blockNumber
  id
  isRepayment
  loanAfter
  rate
  short
  timestamp
}

input Short_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  account: Bytes
  account_contains: Bytes
  account_gt: Bytes
  account_gte: Bytes
  account_in: [Bytes!]
  account_lt: Bytes
  account_lte: Bytes
  account_not: Bytes
  account_not_contains: Bytes
  account_not_in: [Bytes!]
  accruedInterestLastUpdateTimestamp: BigInt
  accruedInterestLastUpdateTimestamp_gt: BigInt
  accruedInterestLastUpdateTimestamp_gte: BigInt
  accruedInterestLastUpdateTimestamp_in: [BigInt!]
  accruedInterestLastUpdateTimestamp_lt: BigInt
  accruedInterestLastUpdateTimestamp_lte: BigInt
  accruedInterestLastUpdateTimestamp_not: BigInt
  accruedInterestLastUpdateTimestamp_not_in: [BigInt!]
  and: [Short_filter]
  closedAt: BigInt
  closedAt_gt: BigInt
  closedAt_gte: BigInt
  closedAt_in: [BigInt!]
  closedAt_lt: BigInt
  closedAt_lte: BigInt
  closedAt_not: BigInt
  closedAt_not_in: [BigInt!]
  collateralChanges_: ShortCollateralChange_filter
  collateralLocked: Bytes
  collateralLockedAmount: BigDecimal
  collateralLockedAmount_gt: BigDecimal
  collateralLockedAmount_gte: BigDecimal
  collateralLockedAmount_in: [BigDecimal!]
  collateralLockedAmount_lt: BigDecimal
  collateralLockedAmount_lte: BigDecimal
  collateralLockedAmount_not: BigDecimal
  collateralLockedAmount_not_in: [BigDecimal!]
  collateralLocked_contains: Bytes
  collateralLocked_gt: Bytes
  collateralLocked_gte: Bytes
  collateralLocked_in: [Bytes!]
  collateralLocked_lt: Bytes
  collateralLocked_lte: Bytes
  collateralLocked_not: Bytes
  collateralLocked_not_contains: Bytes
  collateralLocked_not_in: [Bytes!]
  contractData: String
  contractData_: ShortContract_filter
  contractData_contains: String
  contractData_contains_nocase: String
  contractData_ends_with: String
  contractData_ends_with_nocase: String
  contractData_gt: String
  contractData_gte: String
  contractData_in: [String!]
  contractData_lt: String
  contractData_lte: String
  contractData_not: String
  contractData_not_contains: String
  contractData_not_contains_nocase: String
  contractData_not_ends_with: String
  contractData_not_ends_with_nocase: String
  contractData_not_in: [String!]
  contractData_not_starts_with: String
  contractData_not_starts_with_nocase: String
  contractData_starts_with: String
  contractData_starts_with_nocase: String
  createdAt: BigInt
  createdAtBlock: BigInt
  createdAtBlock_gt: BigInt
  createdAtBlock_gte: BigInt
  createdAtBlock_in: [BigInt!]
  createdAtBlock_lt: BigInt
  createdAtBlock_lte: BigInt
  createdAtBlock_not: BigInt
  createdAtBlock_not_in: [BigInt!]
  createdAt_gt: BigInt
  createdAt_gte: BigInt
  createdAt_in: [BigInt!]
  createdAt_lt: BigInt
  createdAt_lte: BigInt
  createdAt_not: BigInt
  createdAt_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  isOpen: Boolean
  isOpen_in: [Boolean!]
  isOpen_not: Boolean
  isOpen_not_in: [Boolean!]
  liquidations_: ShortLiquidation_filter
  loanChanges_: ShortLoanChange_filter
  or: [Short_filter]
  synthBorrowed: Bytes
  synthBorrowedAmount: BigDecimal
  synthBorrowedAmount_gt: BigDecimal
  synthBorrowedAmount_gte: BigDecimal
  synthBorrowedAmount_in: [BigDecimal!]
  synthBorrowedAmount_lt: BigDecimal
  synthBorrowedAmount_lte: BigDecimal
  synthBorrowedAmount_not: BigDecimal
  synthBorrowedAmount_not_in: [BigDecimal!]
  synthBorrowed_contains: Bytes
  synthBorrowed_gt: Bytes
  synthBorrowed_gte: Bytes
  synthBorrowed_in: [Bytes!]
  synthBorrowed_lt: Bytes
  synthBorrowed_lte: Bytes
  synthBorrowed_not: Bytes
  synthBorrowed_not_contains: Bytes
  synthBorrowed_not_in: [Bytes!]
  txHash: String
  txHash_contains: String
  txHash_contains_nocase: String
  txHash_ends_with: String
  txHash_ends_with_nocase: String
  txHash_gt: String
  txHash_gte: String
  txHash_in: [String!]
  txHash_lt: String
  txHash_lte: String
  txHash_not: String
  txHash_not_contains: String
  txHash_not_contains_nocase: String
  txHash_not_ends_with: String
  txHash_not_ends_with_nocase: String
  txHash_not_in: [String!]
  txHash_not_starts_with: String
  txHash_not_starts_with_nocase: String
  txHash_starts_with: String
  txHash_starts_with_nocase: String
}

enum Short_orderBy {
  account
  accruedInterestLastUpdateTimestamp
  closedAt
  collateralChanges
  collateralLocked
  collateralLockedAmount
  contractData
  createdAt
  createdAtBlock
  id
  isOpen
  liquidations
  loanChanges
  synthBorrowed
  synthBorrowedAmount
  txHash
}

type Subscription {
  """
  Access to subgraph metadata
  """
  _meta(block: Block_height): _Meta_
  accountFlaggedForLiquidation(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AccountFlaggedForLiquidation
  accountFlaggedForLiquidations(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: AccountFlaggedForLiquidation_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: AccountFlaggedForLiquidation_filter
  ): [AccountFlaggedForLiquidation!]!
  accountLiquidated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AccountLiquidated
  accountLiquidateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: AccountLiquidated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: AccountLiquidated_filter
  ): [AccountLiquidated!]!
  accountRemovedFromLiquidation(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AccountRemovedFromLiquidation
  accountRemovedFromLiquidations(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: AccountRemovedFromLiquidation_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: AccountRemovedFromLiquidation_filter
  ): [AccountRemovedFromLiquidation!]!
  activeStaker(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ActiveStaker
  activeStakers(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ActiveStaker_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ActiveStaker_filter
  ): [ActiveStaker!]!
  atomicSynthExchange(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AtomicSynthExchange
  atomicSynthExchanges(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: AtomicSynthExchange_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: AtomicSynthExchange_filter
  ): [AtomicSynthExchange!]!
  burned(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Burned
  burneds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Burned_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Burned_filter
  ): [Burned!]!
  candle(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Candle
  candles(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Candle_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Candle_filter
  ): [Candle!]!
  collateralDeposited(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CollateralDeposited
  collateralDepositeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: CollateralDeposited_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: CollateralDeposited_filter
  ): [CollateralDeposited!]!
  collateralWithdrawn(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CollateralWithdrawn
  collateralWithdrawns(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: CollateralWithdrawn_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: CollateralWithdrawn_filter
  ): [CollateralWithdrawn!]!
  dailyBurned(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DailyBurned
  dailyBurneds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: DailyBurned_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: DailyBurned_filter
  ): [DailyBurned!]!
  dailyCandle(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DailyCandle
  dailyCandles(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: DailyCandle_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: DailyCandle_filter
  ): [DailyCandle!]!
  dailyExchangePartner(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DailyExchangePartner
  dailyExchangePartners(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: DailyExchangePartner_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: DailyExchangePartner_filter
  ): [DailyExchangePartner!]!
  dailyIssued(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DailyIssued
  dailyIssueds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: DailyIssued_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: DailyIssued_filter
  ): [DailyIssued!]!
  debtSnapshot(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DebtSnapshot
  debtSnapshots(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: DebtSnapshot_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: DebtSnapshot_filter
  ): [DebtSnapshot!]!
  debtState(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DebtState
  debtStates(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: DebtState_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: DebtState_filter
  ): [DebtState!]!
  delegatedWallet(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DelegatedWallet
  delegatedWallets(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: DelegatedWallet_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: DelegatedWallet_filter
  ): [DelegatedWallet!]!
  exchangeEntryAppended(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ExchangeEntryAppended
  exchangeEntryAppendeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ExchangeEntryAppended_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ExchangeEntryAppended_filter
  ): [ExchangeEntryAppended!]!
  exchangeEntrySettled(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ExchangeEntrySettled
  exchangeEntrySettleds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ExchangeEntrySettled_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ExchangeEntrySettled_filter
  ): [ExchangeEntrySettled!]!
  exchangeFee(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ExchangeFee
  exchangeFees(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ExchangeFee_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ExchangeFee_filter
  ): [ExchangeFee!]!
  exchangePartner(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ExchangePartner
  exchangePartners(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ExchangePartner_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ExchangePartner_filter
  ): [ExchangePartner!]!
  exchangeRebate(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ExchangeRebate
  exchangeRebates(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ExchangeRebate_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ExchangeRebate_filter
  ): [ExchangeRebate!]!
  exchangeReclaim(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ExchangeReclaim
  exchangeReclaims(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ExchangeReclaim_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ExchangeReclaim_filter
  ): [ExchangeReclaim!]!
  exchanger(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Exchanger
  exchangers(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Exchanger_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Exchanger_filter
  ): [Exchanger!]!
  feePeriod(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): FeePeriod
  feePeriods(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: FeePeriod_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: FeePeriod_filter
  ): [FeePeriod!]!
  feeRate(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): FeeRate
  feeRates(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: FeeRate_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: FeeRate_filter
  ): [FeeRate!]!
  feesClaimed(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): FeesClaimed
  feesClaimeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: FeesClaimed_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: FeesClaimed_filter
  ): [FeesClaimed!]!
  futuresMarket(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): FuturesMarket
  futuresMarkets(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: FuturesMarket_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: FuturesMarket_filter
  ): [FuturesMarket!]!
  inversePricingInfo(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): InversePricingInfo
  inversePricingInfos(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: InversePricingInfo_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: InversePricingInfo_filter
  ): [InversePricingInfo!]!
  issued(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Issued
  issueds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Issued_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Issued_filter
  ): [Issued!]!
  issuer(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Issuer
  issuers(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Issuer_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Issuer_filter
  ): [Issuer!]!
  latestRate(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LatestRate
  latestRates(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LatestRate_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LatestRate_filter
  ): [LatestRate!]!
  latestSynthBalance(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LatestSynthBalance
  latestSynthBalances(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LatestSynthBalance_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LatestSynthBalance_filter
  ): [LatestSynthBalance!]!
  loan(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Loan
  loanLiquidated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LoanLiquidated
  loanLiquidateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LoanLiquidated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LoanLiquidated_filter
  ): [LoanLiquidated!]!
  loanPartiallyLiquidated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LoanPartiallyLiquidated
  loanPartiallyLiquidateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LoanPartiallyLiquidated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LoanPartiallyLiquidated_filter
  ): [LoanPartiallyLiquidated!]!
  loanRepaid(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LoanRepaid
  loanRepaids(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LoanRepaid_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LoanRepaid_filter
  ): [LoanRepaid!]!
  loans(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Loan_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Loan_filter
  ): [Loan!]!
  rateUpdate(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RateUpdate
  rateUpdates(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: RateUpdate_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: RateUpdate_filter
  ): [RateUpdate!]!
  rewardEscrowHolder(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RewardEscrowHolder
  rewardEscrowHolders(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: RewardEscrowHolder_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: RewardEscrowHolder_filter
  ): [RewardEscrowHolder!]!
  short(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Short
  shortCollateralChange(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ShortCollateralChange
  shortCollateralChanges(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ShortCollateralChange_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ShortCollateralChange_filter
  ): [ShortCollateralChange!]!
  shortContract(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ShortContract
  shortContractUpdate(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ShortContractUpdate
  shortContractUpdates(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ShortContractUpdate_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ShortContractUpdate_filter
  ): [ShortContractUpdate!]!
  shortContracts(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ShortContract_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ShortContract_filter
  ): [ShortContract!]!
  shortLiquidation(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ShortLiquidation
  shortLiquidations(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ShortLiquidation_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ShortLiquidation_filter
  ): [ShortLiquidation!]!
  shortLoanChange(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ShortLoanChange
  shortLoanChanges(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ShortLoanChange_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ShortLoanChange_filter
  ): [ShortLoanChange!]!
  shorts(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Short_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Short_filter
  ): [Short!]!
  snxholder(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SNXHolder
  snxholders(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: SNXHolder_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: SNXHolder_filter
  ): [SNXHolder!]!
  synth(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Synth
  synthBalance(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SynthBalance
  synthBalances(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: SynthBalance_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: SynthBalance_filter
  ): [SynthBalance!]!
  synthByCurrencyKey(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SynthByCurrencyKey
  synthByCurrencyKeys(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: SynthByCurrencyKey_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: SynthByCurrencyKey_filter
  ): [SynthByCurrencyKey!]!
  synthExchange(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SynthExchange
  synthExchanges(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: SynthExchange_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: SynthExchange_filter
  ): [SynthExchange!]!
  synthetix(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Synthetix
  synthetixes(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Synthetix_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Synthetix_filter
  ): [Synthetix!]!
  synths(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Synth_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Synth_filter
  ): [Synth!]!
  systemSetting(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SystemSetting
  systemSettings(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: SystemSetting_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: SystemSetting_filter
  ): [SystemSetting!]!
  temporaryExchangePartnerTracker(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TemporaryExchangePartnerTracker
  temporaryExchangePartnerTrackers(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: TemporaryExchangePartnerTracker_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: TemporaryExchangePartnerTracker_filter
  ): [TemporaryExchangePartnerTracker!]!
  total(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Total
  totalActiveStaker(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TotalActiveStaker
  totalActiveStakers(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: TotalActiveStaker_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: TotalActiveStaker_filter
  ): [TotalActiveStaker!]!
  totalDailyActiveStaker(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TotalDailyActiveStaker
  totalDailyActiveStakers(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: TotalDailyActiveStaker_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: TotalDailyActiveStaker_filter
  ): [TotalDailyActiveStaker!]!
  totals(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Total_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Total_filter
  ): [Total!]!
  wrapper(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Wrapper
  wrapperBurn(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): WrapperBurn
  wrapperBurns(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: WrapperBurn_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: WrapperBurn_filter
  ): [WrapperBurn!]!
  wrapperMint(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): WrapperMint
  wrapperMints(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: WrapperMint_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: WrapperMint_filter
  ): [WrapperMint!]!
  wrappers(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Wrapper_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Wrapper_filter
  ): [Wrapper!]!
}

type Synth {
  """
  lowercase address of the proxy contract for the synth
  """
  id: ID!
  name: String!
  symbol: String!
  totalSupply: BigDecimal!
}

type SynthBalance {
  account: String!
  address: Bytes!
  amount: BigDecimal!

  """
  timestamp + account + synth address
  """
  id: ID!
  synth: Synth
  timestamp: BigInt!
}

input SynthBalance_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  account: String
  account_contains: String
  account_contains_nocase: String
  account_ends_with: String
  account_ends_with_nocase: String
  account_gt: String
  account_gte: String
  account_in: [String!]
  account_lt: String
  account_lte: String
  account_not: String
  account_not_contains: String
  account_not_contains_nocase: String
  account_not_ends_with: String
  account_not_ends_with_nocase: String
  account_not_in: [String!]
  account_not_starts_with: String
  account_not_starts_with_nocase: String
  account_starts_with: String
  account_starts_with_nocase: String
  address: Bytes
  address_contains: Bytes
  address_gt: Bytes
  address_gte: Bytes
  address_in: [Bytes!]
  address_lt: Bytes
  address_lte: Bytes
  address_not: Bytes
  address_not_contains: Bytes
  address_not_in: [Bytes!]
  amount: BigDecimal
  amount_gt: BigDecimal
  amount_gte: BigDecimal
  amount_in: [BigDecimal!]
  amount_lt: BigDecimal
  amount_lte: BigDecimal
  amount_not: BigDecimal
  amount_not_in: [BigDecimal!]
  and: [SynthBalance_filter]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [SynthBalance_filter]
  synth: String
  synth_: Synth_filter
  synth_contains: String
  synth_contains_nocase: String
  synth_ends_with: String
  synth_ends_with_nocase: String
  synth_gt: String
  synth_gte: String
  synth_in: [String!]
  synth_lt: String
  synth_lte: String
  synth_not: String
  synth_not_contains: String
  synth_not_contains_nocase: String
  synth_not_ends_with: String
  synth_not_ends_with_nocase: String
  synth_not_in: [String!]
  synth_not_starts_with: String
  synth_not_starts_with_nocase: String
  synth_starts_with: String
  synth_starts_with_nocase: String
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
}

enum SynthBalance_orderBy {
  account
  address
  amount
  id
  synth
  timestamp
}

"THIS FILE IS AUTOMATICALLY GENERATED BY THE DEPLOY SCRIPT\n"
type SynthByCurrencyKey {
  """
  currency key
  """
  id: ID!
  proxyAddress: Bytes!
}

input SynthByCurrencyKey_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [SynthByCurrencyKey_filter]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [SynthByCurrencyKey_filter]
  proxyAddress: Bytes
  proxyAddress_contains: Bytes
  proxyAddress_gt: Bytes
  proxyAddress_gte: Bytes
  proxyAddress_in: [Bytes!]
  proxyAddress_lt: Bytes
  proxyAddress_lte: Bytes
  proxyAddress_not: Bytes
  proxyAddress_not_contains: Bytes
  proxyAddress_not_in: [Bytes!]
}

enum SynthByCurrencyKey_orderBy {
  id
  proxyAddress
}

"""
Tracks this event from the Synthetix.sol contract
"""
type SynthExchange {
  account: Exchanger!
  feesInUSD: BigDecimal!
  fromAmount: BigDecimal!
  fromAmountInUSD: BigDecimal!
  fromSynth: Synth
  gasPrice: BigInt!
  id: ID!
  timestamp: BigInt!
  toAddress: Bytes!
  toAmount: BigDecimal!
  toAmountInUSD: BigDecimal!
  toSynth: Synth
}

input SynthExchange_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  account: String
  account_: Exchanger_filter
  account_contains: String
  account_contains_nocase: String
  account_ends_with: String
  account_ends_with_nocase: String
  account_gt: String
  account_gte: String
  account_in: [String!]
  account_lt: String
  account_lte: String
  account_not: String
  account_not_contains: String
  account_not_contains_nocase: String
  account_not_ends_with: String
  account_not_ends_with_nocase: String
  account_not_in: [String!]
  account_not_starts_with: String
  account_not_starts_with_nocase: String
  account_starts_with: String
  account_starts_with_nocase: String
  and: [SynthExchange_filter]
  feesInUSD: BigDecimal
  feesInUSD_gt: BigDecimal
  feesInUSD_gte: BigDecimal
  feesInUSD_in: [BigDecimal!]
  feesInUSD_lt: BigDecimal
  feesInUSD_lte: BigDecimal
  feesInUSD_not: BigDecimal
  feesInUSD_not_in: [BigDecimal!]
  fromAmount: BigDecimal
  fromAmountInUSD: BigDecimal
  fromAmountInUSD_gt: BigDecimal
  fromAmountInUSD_gte: BigDecimal
  fromAmountInUSD_in: [BigDecimal!]
  fromAmountInUSD_lt: BigDecimal
  fromAmountInUSD_lte: BigDecimal
  fromAmountInUSD_not: BigDecimal
  fromAmountInUSD_not_in: [BigDecimal!]
  fromAmount_gt: BigDecimal
  fromAmount_gte: BigDecimal
  fromAmount_in: [BigDecimal!]
  fromAmount_lt: BigDecimal
  fromAmount_lte: BigDecimal
  fromAmount_not: BigDecimal
  fromAmount_not_in: [BigDecimal!]
  fromSynth: String
  fromSynth_: Synth_filter
  fromSynth_contains: String
  fromSynth_contains_nocase: String
  fromSynth_ends_with: String
  fromSynth_ends_with_nocase: String
  fromSynth_gt: String
  fromSynth_gte: String
  fromSynth_in: [String!]
  fromSynth_lt: String
  fromSynth_lte: String
  fromSynth_not: String
  fromSynth_not_contains: String
  fromSynth_not_contains_nocase: String
  fromSynth_not_ends_with: String
  fromSynth_not_ends_with_nocase: String
  fromSynth_not_in: [String!]
  fromSynth_not_starts_with: String
  fromSynth_not_starts_with_nocase: String
  fromSynth_starts_with: String
  fromSynth_starts_with_nocase: String
  gasPrice: BigInt
  gasPrice_gt: BigInt
  gasPrice_gte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_lt: BigInt
  gasPrice_lte: BigInt
  gasPrice_not: BigInt
  gasPrice_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [SynthExchange_filter]
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  toAddress: Bytes
  toAddress_contains: Bytes
  toAddress_gt: Bytes
  toAddress_gte: Bytes
  toAddress_in: [Bytes!]
  toAddress_lt: Bytes
  toAddress_lte: Bytes
  toAddress_not: Bytes
  toAddress_not_contains: Bytes
  toAddress_not_in: [Bytes!]
  toAmount: BigDecimal
  toAmountInUSD: BigDecimal
  toAmountInUSD_gt: BigDecimal
  toAmountInUSD_gte: BigDecimal
  toAmountInUSD_in: [BigDecimal!]
  toAmountInUSD_lt: BigDecimal
  toAmountInUSD_lte: BigDecimal
  toAmountInUSD_not: BigDecimal
  toAmountInUSD_not_in: [BigDecimal!]
  toAmount_gt: BigDecimal
  toAmount_gte: BigDecimal
  toAmount_in: [BigDecimal!]
  toAmount_lt: BigDecimal
  toAmount_lte: BigDecimal
  toAmount_not: BigDecimal
  toAmount_not_in: [BigDecimal!]
  toSynth: String
  toSynth_: Synth_filter
  toSynth_contains: String
  toSynth_contains_nocase: String
  toSynth_ends_with: String
  toSynth_ends_with_nocase: String
  toSynth_gt: String
  toSynth_gte: String
  toSynth_in: [String!]
  toSynth_lt: String
  toSynth_lte: String
  toSynth_not: String
  toSynth_not_contains: String
  toSynth_not_contains_nocase: String
  toSynth_not_ends_with: String
  toSynth_not_ends_with_nocase: String
  toSynth_not_in: [String!]
  toSynth_not_starts_with: String
  toSynth_not_starts_with_nocase: String
  toSynth_starts_with: String
  toSynth_starts_with_nocase: String
}

enum SynthExchange_orderBy {
  account
  feesInUSD
  fromAmount
  fromAmountInUSD
  fromSynth
  gasPrice
  id
  timestamp
  toAddress
  toAmount
  toAmountInUSD
  toSynth
}

input Synth_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [Synth_filter]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  name: String
  name_contains: String
  name_contains_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  or: [Synth_filter]
  symbol: String
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_gt: String
  symbol_gte: String
  symbol_in: [String!]
  symbol_lt: String
  symbol_lte: String
  symbol_not: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  symbol_not_in: [String!]
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
  totalSupply: BigDecimal
  totalSupply_gt: BigDecimal
  totalSupply_gte: BigDecimal
  totalSupply_in: [BigDecimal!]
  totalSupply_lt: BigDecimal
  totalSupply_lte: BigDecimal
  totalSupply_not: BigDecimal
  totalSupply_not_in: [BigDecimal!]
}

enum Synth_orderBy {
  id
  name
  symbol
  totalSupply
}

"""
Synthentix is an aggregation entity
"""
type Synthetix {
  id: ID!

  """
  number of stakers currently staking
  """
  issuers: BigInt!

  """
  number of addresses which hold SNX
  """
  snxHolders: BigInt!
}

input Synthetix_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [Synthetix_filter]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  issuers: BigInt
  issuers_gt: BigInt
  issuers_gte: BigInt
  issuers_in: [BigInt!]
  issuers_lt: BigInt
  issuers_lte: BigInt
  issuers_not: BigInt
  issuers_not_in: [BigInt!]
  or: [Synthetix_filter]
  snxHolders: BigInt
  snxHolders_gt: BigInt
  snxHolders_gte: BigInt
  snxHolders_in: [BigInt!]
  snxHolders_lt: BigInt
  snxHolders_lte: BigInt
  snxHolders_not: BigInt
  snxHolders_not_in: [BigInt!]
}

enum Synthetix_orderBy {
  id
  issuers
  snxHolders
}

type SystemSetting {
  aggregatorWarningFlags: String!

  """
  SIP-120 Atomic exchanges: max allowed volume per block for atomic exchanges
  """
  atomicMaxVolumePerBlock: BigInt!

  """
  SIP-120 Atomic exchanges: time window (in seconds) for TWAP prices when considered for atomic exchanges
  """
  atomicTwapWindow: BigInt!
  debtSnapshotStaleTime: BigInt!

  """
  SIP 112: ETH Wrappr: The fee for burning sETH and releasing ETH from the EtherWrapper.
  """
  etherWrapperBurnFeeRate: BigDecimal!

  """
  SIP 112: ETH Wrappr: The maximum amount of ETH held by the EtherWrapper.
  """
  etherWrapperMaxETH: BigDecimal!

  """
  SIP 112: ETH Wrappr: The fee for depositing ETH into the EtherWrapper.
  """
  etherWrapperMintFeeRate: BigDecimal!

  """
  How long a fee period lasts at a minimum. It is required for anyone to roll over the periods, so they are not guaranteed to roll over at exactly this duration, but the contract enforces that they cannot roll over any quicker than this duration.
  """
  feePeriodDuration: BigInt!
  id: ID!

  """
  The raio of collateral Expressed in 18 decimals. So 800% cratio is 100/800 = 0.125 (0.125e18)
  """
  issuanceRatio: BigDecimal!

  """
  SIP-15 Liquidations: liquidation time delay after address flagged (seconds)
  """
  liquidationDelay: BigInt!

  """
  SIP-15 Liquidations: penalty taken away from target of liquidation (with 18 decimals). E.g. 10% is 0.1e18
  """
  liquidationPenalty: BigDecimal!

  """
  SIP-15 Liquidations: issuance ratio when account can be flagged for liquidation (with 18 decimals), e.g 0.5 issuance ratio when flag means 1/0.5 = 200% cratio
  """
  liquidationRatio: BigDecimal!
  minimumStakeTime: BigInt!

  """
  SIP-65 Decentralized Circuit Breaker: The factor amount expressed in decimal format E.g. 3e18 = factor 3, meaning movement up to 3x and above or down to 1/3x and below
  """
  priceDeviationThresholdFactor: BigDecimal!

  """
  How long will the ExchangeRates contract assume the rate of any asset is correct
  """
  rateStalePeriod: BigInt!

  """
  Users are unable to claim fees if their collateralisation ratio drifts out of target threshold
  """
  targetThreshold: BigDecimal!

  """
  time at which these values are recorded
  """
  timestamp: BigInt!

  """
  SIP-37 Fee Reclamation: The number of seconds after an exchange is executed that must be waited before settlement.
  """
  waitingPeriodSecs: BigInt!
}

input SystemSetting_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  aggregatorWarningFlags: String
  aggregatorWarningFlags_contains: String
  aggregatorWarningFlags_contains_nocase: String
  aggregatorWarningFlags_ends_with: String
  aggregatorWarningFlags_ends_with_nocase: String
  aggregatorWarningFlags_gt: String
  aggregatorWarningFlags_gte: String
  aggregatorWarningFlags_in: [String!]
  aggregatorWarningFlags_lt: String
  aggregatorWarningFlags_lte: String
  aggregatorWarningFlags_not: String
  aggregatorWarningFlags_not_contains: String
  aggregatorWarningFlags_not_contains_nocase: String
  aggregatorWarningFlags_not_ends_with: String
  aggregatorWarningFlags_not_ends_with_nocase: String
  aggregatorWarningFlags_not_in: [String!]
  aggregatorWarningFlags_not_starts_with: String
  aggregatorWarningFlags_not_starts_with_nocase: String
  aggregatorWarningFlags_starts_with: String
  aggregatorWarningFlags_starts_with_nocase: String
  and: [SystemSetting_filter]
  atomicMaxVolumePerBlock: BigInt
  atomicMaxVolumePerBlock_gt: BigInt
  atomicMaxVolumePerBlock_gte: BigInt
  atomicMaxVolumePerBlock_in: [BigInt!]
  atomicMaxVolumePerBlock_lt: BigInt
  atomicMaxVolumePerBlock_lte: BigInt
  atomicMaxVolumePerBlock_not: BigInt
  atomicMaxVolumePerBlock_not_in: [BigInt!]
  atomicTwapWindow: BigInt
  atomicTwapWindow_gt: BigInt
  atomicTwapWindow_gte: BigInt
  atomicTwapWindow_in: [BigInt!]
  atomicTwapWindow_lt: BigInt
  atomicTwapWindow_lte: BigInt
  atomicTwapWindow_not: BigInt
  atomicTwapWindow_not_in: [BigInt!]
  debtSnapshotStaleTime: BigInt
  debtSnapshotStaleTime_gt: BigInt
  debtSnapshotStaleTime_gte: BigInt
  debtSnapshotStaleTime_in: [BigInt!]
  debtSnapshotStaleTime_lt: BigInt
  debtSnapshotStaleTime_lte: BigInt
  debtSnapshotStaleTime_not: BigInt
  debtSnapshotStaleTime_not_in: [BigInt!]
  etherWrapperBurnFeeRate: BigDecimal
  etherWrapperBurnFeeRate_gt: BigDecimal
  etherWrapperBurnFeeRate_gte: BigDecimal
  etherWrapperBurnFeeRate_in: [BigDecimal!]
  etherWrapperBurnFeeRate_lt: BigDecimal
  etherWrapperBurnFeeRate_lte: BigDecimal
  etherWrapperBurnFeeRate_not: BigDecimal
  etherWrapperBurnFeeRate_not_in: [BigDecimal!]
  etherWrapperMaxETH: BigDecimal
  etherWrapperMaxETH_gt: BigDecimal
  etherWrapperMaxETH_gte: BigDecimal
  etherWrapperMaxETH_in: [BigDecimal!]
  etherWrapperMaxETH_lt: BigDecimal
  etherWrapperMaxETH_lte: BigDecimal
  etherWrapperMaxETH_not: BigDecimal
  etherWrapperMaxETH_not_in: [BigDecimal!]
  etherWrapperMintFeeRate: BigDecimal
  etherWrapperMintFeeRate_gt: BigDecimal
  etherWrapperMintFeeRate_gte: BigDecimal
  etherWrapperMintFeeRate_in: [BigDecimal!]
  etherWrapperMintFeeRate_lt: BigDecimal
  etherWrapperMintFeeRate_lte: BigDecimal
  etherWrapperMintFeeRate_not: BigDecimal
  etherWrapperMintFeeRate_not_in: [BigDecimal!]
  feePeriodDuration: BigInt
  feePeriodDuration_gt: BigInt
  feePeriodDuration_gte: BigInt
  feePeriodDuration_in: [BigInt!]
  feePeriodDuration_lt: BigInt
  feePeriodDuration_lte: BigInt
  feePeriodDuration_not: BigInt
  feePeriodDuration_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  issuanceRatio: BigDecimal
  issuanceRatio_gt: BigDecimal
  issuanceRatio_gte: BigDecimal
  issuanceRatio_in: [BigDecimal!]
  issuanceRatio_lt: BigDecimal
  issuanceRatio_lte: BigDecimal
  issuanceRatio_not: BigDecimal
  issuanceRatio_not_in: [BigDecimal!]
  liquidationDelay: BigInt
  liquidationDelay_gt: BigInt
  liquidationDelay_gte: BigInt
  liquidationDelay_in: [BigInt!]
  liquidationDelay_lt: BigInt
  liquidationDelay_lte: BigInt
  liquidationDelay_not: BigInt
  liquidationDelay_not_in: [BigInt!]
  liquidationPenalty: BigDecimal
  liquidationPenalty_gt: BigDecimal
  liquidationPenalty_gte: BigDecimal
  liquidationPenalty_in: [BigDecimal!]
  liquidationPenalty_lt: BigDecimal
  liquidationPenalty_lte: BigDecimal
  liquidationPenalty_not: BigDecimal
  liquidationPenalty_not_in: [BigDecimal!]
  liquidationRatio: BigDecimal
  liquidationRatio_gt: BigDecimal
  liquidationRatio_gte: BigDecimal
  liquidationRatio_in: [BigDecimal!]
  liquidationRatio_lt: BigDecimal
  liquidationRatio_lte: BigDecimal
  liquidationRatio_not: BigDecimal
  liquidationRatio_not_in: [BigDecimal!]
  minimumStakeTime: BigInt
  minimumStakeTime_gt: BigInt
  minimumStakeTime_gte: BigInt
  minimumStakeTime_in: [BigInt!]
  minimumStakeTime_lt: BigInt
  minimumStakeTime_lte: BigInt
  minimumStakeTime_not: BigInt
  minimumStakeTime_not_in: [BigInt!]
  or: [SystemSetting_filter]
  priceDeviationThresholdFactor: BigDecimal
  priceDeviationThresholdFactor_gt: BigDecimal
  priceDeviationThresholdFactor_gte: BigDecimal
  priceDeviationThresholdFactor_in: [BigDecimal!]
  priceDeviationThresholdFactor_lt: BigDecimal
  priceDeviationThresholdFactor_lte: BigDecimal
  priceDeviationThresholdFactor_not: BigDecimal
  priceDeviationThresholdFactor_not_in: [BigDecimal!]
  rateStalePeriod: BigInt
  rateStalePeriod_gt: BigInt
  rateStalePeriod_gte: BigInt
  rateStalePeriod_in: [BigInt!]
  rateStalePeriod_lt: BigInt
  rateStalePeriod_lte: BigInt
  rateStalePeriod_not: BigInt
  rateStalePeriod_not_in: [BigInt!]
  targetThreshold: BigDecimal
  targetThreshold_gt: BigDecimal
  targetThreshold_gte: BigDecimal
  targetThreshold_in: [BigDecimal!]
  targetThreshold_lt: BigDecimal
  targetThreshold_lte: BigDecimal
  targetThreshold_not: BigDecimal
  targetThreshold_not_in: [BigDecimal!]
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  waitingPeriodSecs: BigInt
  waitingPeriodSecs_gt: BigInt
  waitingPeriodSecs_gte: BigInt
  waitingPeriodSecs_in: [BigInt!]
  waitingPeriodSecs_lt: BigInt
  waitingPeriodSecs_lte: BigInt
  waitingPeriodSecs_not: BigInt
  waitingPeriodSecs_not_in: [BigInt!]
}

enum SystemSetting_orderBy {
  aggregatorWarningFlags
  atomicMaxVolumePerBlock
  atomicTwapWindow
  debtSnapshotStaleTime
  etherWrapperBurnFeeRate
  etherWrapperMaxETH
  etherWrapperMintFeeRate
  feePeriodDuration
  id
  issuanceRatio
  liquidationDelay
  liquidationPenalty
  liquidationRatio
  minimumStakeTime
  priceDeviationThresholdFactor
  rateStalePeriod
  targetThreshold
  timestamp
  waitingPeriodSecs
}

type TemporaryExchangePartnerTracker {
  """
  Transaction hash of the Exchange event
  """
  id: ID!

  """
  String format of the tracking code for a given partner
  """
  partner: String

  """
  Total fees from this transaction hash
  """
  usdFees: BigDecimal

  """
  Total transaction volume in USD across all ExchangeEntryAppended events in a single tx hash
  """
  usdVolume: BigDecimal
}

input TemporaryExchangePartnerTracker_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [TemporaryExchangePartnerTracker_filter]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [TemporaryExchangePartnerTracker_filter]
  partner: String
  partner_contains: String
  partner_contains_nocase: String
  partner_ends_with: String
  partner_ends_with_nocase: String
  partner_gt: String
  partner_gte: String
  partner_in: [String!]
  partner_lt: String
  partner_lte: String
  partner_not: String
  partner_not_contains: String
  partner_not_contains_nocase: String
  partner_not_ends_with: String
  partner_not_ends_with_nocase: String
  partner_not_in: [String!]
  partner_not_starts_with: String
  partner_not_starts_with_nocase: String
  partner_starts_with: String
  partner_starts_with_nocase: String
  usdFees: BigDecimal
  usdFees_gt: BigDecimal
  usdFees_gte: BigDecimal
  usdFees_in: [BigDecimal!]
  usdFees_lt: BigDecimal
  usdFees_lte: BigDecimal
  usdFees_not: BigDecimal
  usdFees_not_in: [BigDecimal!]
  usdVolume: BigDecimal
  usdVolume_gt: BigDecimal
  usdVolume_gte: BigDecimal
  usdVolume_in: [BigDecimal!]
  usdVolume_lt: BigDecimal
  usdVolume_lte: BigDecimal
  usdVolume_not: BigDecimal
  usdVolume_not_in: [BigDecimal!]
}

enum TemporaryExchangePartnerTracker_orderBy {
  id
  partner
  usdFees
  usdVolume
}

type Total {
  """
  minimum power of 10 (in from USD value) the trade must be. ex, 2 means $100 or higher)
  """
  bucketMagnitude: BigInt!

  """
  synth value exchanged in USD units
  """
  exchangeUSDTally: BigDecimal!

  """
  number of unique traders seen over period
  """
  exchangers: BigInt!

  """
  $timestamp-$bucketMagnitude-$synth-$period
  """
  id: ID!

  """
  number of unique traders who were first seen in this period
  """
  newExchangers: BigInt!

  """
  number of seconds the data covers after `timestamp`
  """
  period: BigInt!

  """
  which product the volume came from. Ex 'futures' or 'exchange'
  """
  product: String!

  """
  synth to filter by
  """
  synth: Synth

  """
  timestamp of the beginning of the time period this represents
  """
  timestamp: BigInt!

  """
  synth value received in fees in USD units
  """
  totalFeesGeneratedInUSD: BigDecimal!

  """
  number of trades completed over period
  """
  trades: BigInt!
}

type TotalActiveStaker {
  """
  number of stakers seen
  """
  count: BigInt!

  """
  single value
  """
  id: ID!
}

input TotalActiveStaker_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [TotalActiveStaker_filter]
  count: BigInt
  count_gt: BigInt
  count_gte: BigInt
  count_in: [BigInt!]
  count_lt: BigInt
  count_lte: BigInt
  count_not: BigInt
  count_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [TotalActiveStaker_filter]
}

enum TotalActiveStaker_orderBy {
  count
  id
}

type TotalDailyActiveStaker {
  """
  number of stakers seen on this day
  """
  count: BigInt!

  """
  unix timestamp at beginning of day relevant to this statistic
  """
  id: ID!

  """
  unix timestamp as a BigInt (so it can be filtered)
  """
  timestamp: BigInt!
}

input TotalDailyActiveStaker_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [TotalDailyActiveStaker_filter]
  count: BigInt
  count_gt: BigInt
  count_gte: BigInt
  count_in: [BigInt!]
  count_lt: BigInt
  count_lte: BigInt
  count_not: BigInt
  count_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [TotalDailyActiveStaker_filter]
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
}

enum TotalDailyActiveStaker_orderBy {
  count
  id
  timestamp
}

input Total_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [Total_filter]
  bucketMagnitude: BigInt
  bucketMagnitude_gt: BigInt
  bucketMagnitude_gte: BigInt
  bucketMagnitude_in: [BigInt!]
  bucketMagnitude_lt: BigInt
  bucketMagnitude_lte: BigInt
  bucketMagnitude_not: BigInt
  bucketMagnitude_not_in: [BigInt!]
  exchangeUSDTally: BigDecimal
  exchangeUSDTally_gt: BigDecimal
  exchangeUSDTally_gte: BigDecimal
  exchangeUSDTally_in: [BigDecimal!]
  exchangeUSDTally_lt: BigDecimal
  exchangeUSDTally_lte: BigDecimal
  exchangeUSDTally_not: BigDecimal
  exchangeUSDTally_not_in: [BigDecimal!]
  exchangers: BigInt
  exchangers_gt: BigInt
  exchangers_gte: BigInt
  exchangers_in: [BigInt!]
  exchangers_lt: BigInt
  exchangers_lte: BigInt
  exchangers_not: BigInt
  exchangers_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  newExchangers: BigInt
  newExchangers_gt: BigInt
  newExchangers_gte: BigInt
  newExchangers_in: [BigInt!]
  newExchangers_lt: BigInt
  newExchangers_lte: BigInt
  newExchangers_not: BigInt
  newExchangers_not_in: [BigInt!]
  or: [Total_filter]
  period: BigInt
  period_gt: BigInt
  period_gte: BigInt
  period_in: [BigInt!]
  period_lt: BigInt
  period_lte: BigInt
  period_not: BigInt
  period_not_in: [BigInt!]
  product: String
  product_contains: String
  product_contains_nocase: String
  product_ends_with: String
  product_ends_with_nocase: String
  product_gt: String
  product_gte: String
  product_in: [String!]
  product_lt: String
  product_lte: String
  product_not: String
  product_not_contains: String
  product_not_contains_nocase: String
  product_not_ends_with: String
  product_not_ends_with_nocase: String
  product_not_in: [String!]
  product_not_starts_with: String
  product_not_starts_with_nocase: String
  product_starts_with: String
  product_starts_with_nocase: String
  synth: String
  synth_: Synth_filter
  synth_contains: String
  synth_contains_nocase: String
  synth_ends_with: String
  synth_ends_with_nocase: String
  synth_gt: String
  synth_gte: String
  synth_in: [String!]
  synth_lt: String
  synth_lte: String
  synth_not: String
  synth_not_contains: String
  synth_not_contains_nocase: String
  synth_not_ends_with: String
  synth_not_ends_with_nocase: String
  synth_not_in: [String!]
  synth_not_starts_with: String
  synth_not_starts_with_nocase: String
  synth_starts_with: String
  synth_starts_with_nocase: String
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  totalFeesGeneratedInUSD: BigDecimal
  totalFeesGeneratedInUSD_gt: BigDecimal
  totalFeesGeneratedInUSD_gte: BigDecimal
  totalFeesGeneratedInUSD_in: [BigDecimal!]
  totalFeesGeneratedInUSD_lt: BigDecimal
  totalFeesGeneratedInUSD_lte: BigDecimal
  totalFeesGeneratedInUSD_not: BigDecimal
  totalFeesGeneratedInUSD_not_in: [BigDecimal!]
  trades: BigInt
  trades_gt: BigInt
  trades_gte: BigInt
  trades_in: [BigInt!]
  trades_lt: BigInt
  trades_lte: BigInt
  trades_not: BigInt
  trades_not_in: [BigInt!]
}

enum Total_orderBy {
  bucketMagnitude
  exchangeUSDTally
  exchangers
  id
  newExchangers
  period
  product
  synth
  timestamp
  totalFeesGeneratedInUSD
  trades
}

type Wrapper {
  """
  the current amount of synths minted by this wrapper
  """
  amount: BigDecimal!

  """
  the current amount of synths minted by this wrapper in USD
  """
  amountInUSD: BigDecimal!

  """
  the currency key of this wrapper
  """
  currencyKey: String!

  """
  wrapper address
  """
  id: ID!

  """
  the maximum amount of synths that can be minted by this wrapper
  """
  maxAmount: BigDecimal!

  """
  address of wrapped token, empty if ETH
  """
  tokenAddress: String!

  """
  the total amount of fees generated by this wrapper
  """
  totalFees: BigDecimal!

  """
  the total amount of fees generated by this wrapper in USD
  """
  totalFeesInUSD: BigDecimal!
}

type WrapperBurn {
  """
  address of the user burning
  """
  account: String!

  """
  total amount removed from the wrapper
  """
  amountOut: BigDecimal!

  """
  amount of fees collected
  """
  fee: BigDecimal!

  """
  the transaction hash with a log index appended
  """
  id: ID!

  """
  amount of synth burned
  """
  principal: BigDecimal!

  """
  the timestamp of the block that includes this event
  """
  timestamp: BigInt!

  """
  the address of the wrapper that burned this synth
  """
  wrapperAddress: String!
}

input WrapperBurn_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  account: String
  account_contains: String
  account_contains_nocase: String
  account_ends_with: String
  account_ends_with_nocase: String
  account_gt: String
  account_gte: String
  account_in: [String!]
  account_lt: String
  account_lte: String
  account_not: String
  account_not_contains: String
  account_not_contains_nocase: String
  account_not_ends_with: String
  account_not_ends_with_nocase: String
  account_not_in: [String!]
  account_not_starts_with: String
  account_not_starts_with_nocase: String
  account_starts_with: String
  account_starts_with_nocase: String
  amountOut: BigDecimal
  amountOut_gt: BigDecimal
  amountOut_gte: BigDecimal
  amountOut_in: [BigDecimal!]
  amountOut_lt: BigDecimal
  amountOut_lte: BigDecimal
  amountOut_not: BigDecimal
  amountOut_not_in: [BigDecimal!]
  and: [WrapperBurn_filter]
  fee: BigDecimal
  fee_gt: BigDecimal
  fee_gte: BigDecimal
  fee_in: [BigDecimal!]
  fee_lt: BigDecimal
  fee_lte: BigDecimal
  fee_not: BigDecimal
  fee_not_in: [BigDecimal!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [WrapperBurn_filter]
  principal: BigDecimal
  principal_gt: BigDecimal
  principal_gte: BigDecimal
  principal_in: [BigDecimal!]
  principal_lt: BigDecimal
  principal_lte: BigDecimal
  principal_not: BigDecimal
  principal_not_in: [BigDecimal!]
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  wrapperAddress: String
  wrapperAddress_contains: String
  wrapperAddress_contains_nocase: String
  wrapperAddress_ends_with: String
  wrapperAddress_ends_with_nocase: String
  wrapperAddress_gt: String
  wrapperAddress_gte: String
  wrapperAddress_in: [String!]
  wrapperAddress_lt: String
  wrapperAddress_lte: String
  wrapperAddress_not: String
  wrapperAddress_not_contains: String
  wrapperAddress_not_contains_nocase: String
  wrapperAddress_not_ends_with: String
  wrapperAddress_not_ends_with_nocase: String
  wrapperAddress_not_in: [String!]
  wrapperAddress_not_starts_with: String
  wrapperAddress_not_starts_with_nocase: String
  wrapperAddress_starts_with: String
  wrapperAddress_starts_with_nocase: String
}

enum WrapperBurn_orderBy {
  account
  amountOut
  fee
  id
  principal
  timestamp
  wrapperAddress
}

type WrapperMint {
  """
  address of the user minting
  """
  account: String!

  """
  total amount added to the wrapper
  """
  amountIn: BigDecimal!

  """
  amount of fees collected
  """
  fee: BigDecimal!

  """
  the transaction hash with a log index appended
  """
  id: ID!

  """
  amount of synth minted
  """
  principal: BigDecimal!

  """
  the timestamp of the block that includes this event
  """
  timestamp: BigInt!

  """
  the address of the wrapper that minted this synth
  """
  wrapperAddress: String!
}

input WrapperMint_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  account: String
  account_contains: String
  account_contains_nocase: String
  account_ends_with: String
  account_ends_with_nocase: String
  account_gt: String
  account_gte: String
  account_in: [String!]
  account_lt: String
  account_lte: String
  account_not: String
  account_not_contains: String
  account_not_contains_nocase: String
  account_not_ends_with: String
  account_not_ends_with_nocase: String
  account_not_in: [String!]
  account_not_starts_with: String
  account_not_starts_with_nocase: String
  account_starts_with: String
  account_starts_with_nocase: String
  amountIn: BigDecimal
  amountIn_gt: BigDecimal
  amountIn_gte: BigDecimal
  amountIn_in: [BigDecimal!]
  amountIn_lt: BigDecimal
  amountIn_lte: BigDecimal
  amountIn_not: BigDecimal
  amountIn_not_in: [BigDecimal!]
  and: [WrapperMint_filter]
  fee: BigDecimal
  fee_gt: BigDecimal
  fee_gte: BigDecimal
  fee_in: [BigDecimal!]
  fee_lt: BigDecimal
  fee_lte: BigDecimal
  fee_not: BigDecimal
  fee_not_in: [BigDecimal!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [WrapperMint_filter]
  principal: BigDecimal
  principal_gt: BigDecimal
  principal_gte: BigDecimal
  principal_in: [BigDecimal!]
  principal_lt: BigDecimal
  principal_lte: BigDecimal
  principal_not: BigDecimal
  principal_not_in: [BigDecimal!]
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  wrapperAddress: String
  wrapperAddress_contains: String
  wrapperAddress_contains_nocase: String
  wrapperAddress_ends_with: String
  wrapperAddress_ends_with_nocase: String
  wrapperAddress_gt: String
  wrapperAddress_gte: String
  wrapperAddress_in: [String!]
  wrapperAddress_lt: String
  wrapperAddress_lte: String
  wrapperAddress_not: String
  wrapperAddress_not_contains: String
  wrapperAddress_not_contains_nocase: String
  wrapperAddress_not_ends_with: String
  wrapperAddress_not_ends_with_nocase: String
  wrapperAddress_not_in: [String!]
  wrapperAddress_not_starts_with: String
  wrapperAddress_not_starts_with_nocase: String
  wrapperAddress_starts_with: String
  wrapperAddress_starts_with_nocase: String
}

enum WrapperMint_orderBy {
  account
  amountIn
  fee
  id
  principal
  timestamp
  wrapperAddress
}

input Wrapper_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  amount: BigDecimal
  amountInUSD: BigDecimal
  amountInUSD_gt: BigDecimal
  amountInUSD_gte: BigDecimal
  amountInUSD_in: [BigDecimal!]
  amountInUSD_lt: BigDecimal
  amountInUSD_lte: BigDecimal
  amountInUSD_not: BigDecimal
  amountInUSD_not_in: [BigDecimal!]
  amount_gt: BigDecimal
  amount_gte: BigDecimal
  amount_in: [BigDecimal!]
  amount_lt: BigDecimal
  amount_lte: BigDecimal
  amount_not: BigDecimal
  amount_not_in: [BigDecimal!]
  and: [Wrapper_filter]
  currencyKey: String
  currencyKey_contains: String
  currencyKey_contains_nocase: String
  currencyKey_ends_with: String
  currencyKey_ends_with_nocase: String
  currencyKey_gt: String
  currencyKey_gte: String
  currencyKey_in: [String!]
  currencyKey_lt: String
  currencyKey_lte: String
  currencyKey_not: String
  currencyKey_not_contains: String
  currencyKey_not_contains_nocase: String
  currencyKey_not_ends_with: String
  currencyKey_not_ends_with_nocase: String
  currencyKey_not_in: [String!]
  currencyKey_not_starts_with: String
  currencyKey_not_starts_with_nocase: String
  currencyKey_starts_with: String
  currencyKey_starts_with_nocase: String
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  maxAmount: BigDecimal
  maxAmount_gt: BigDecimal
  maxAmount_gte: BigDecimal
  maxAmount_in: [BigDecimal!]
  maxAmount_lt: BigDecimal
  maxAmount_lte: BigDecimal
  maxAmount_not: BigDecimal
  maxAmount_not_in: [BigDecimal!]
  or: [Wrapper_filter]
  tokenAddress: String
  tokenAddress_contains: String
  tokenAddress_contains_nocase: String
  tokenAddress_ends_with: String
  tokenAddress_ends_with_nocase: String
  tokenAddress_gt: String
  tokenAddress_gte: String
  tokenAddress_in: [String!]
  tokenAddress_lt: String
  tokenAddress_lte: String
  tokenAddress_not: String
  tokenAddress_not_contains: String
  tokenAddress_not_contains_nocase: String
  tokenAddress_not_ends_with: String
  tokenAddress_not_ends_with_nocase: String
  tokenAddress_not_in: [String!]
  tokenAddress_not_starts_with: String
  tokenAddress_not_starts_with_nocase: String
  tokenAddress_starts_with: String
  tokenAddress_starts_with_nocase: String
  totalFees: BigDecimal
  totalFeesInUSD: BigDecimal
  totalFeesInUSD_gt: BigDecimal
  totalFeesInUSD_gte: BigDecimal
  totalFeesInUSD_in: [BigDecimal!]
  totalFeesInUSD_lt: BigDecimal
  totalFeesInUSD_lte: BigDecimal
  totalFeesInUSD_not: BigDecimal
  totalFeesInUSD_not_in: [BigDecimal!]
  totalFees_gt: BigDecimal
  totalFees_gte: BigDecimal
  totalFees_in: [BigDecimal!]
  totalFees_lt: BigDecimal
  totalFees_lte: BigDecimal
  totalFees_not: BigDecimal
  totalFees_not_in: [BigDecimal!]
}

enum Wrapper_orderBy {
  amount
  amountInUSD
  currencyKey
  id
  maxAmount
  tokenAddress
  totalFees
  totalFeesInUSD
}

type _Block_ {
  """
  The hash of the block
  """
  hash: Bytes

  """
  The block number
  """
  number: Int!

  """
  Integer representation of the timestamp stored in blocks for the chain
  """
  timestamp: Int
}

"""
The type for the top-level _meta field
"""
type _Meta_ {
  "Information about a specific subgraph block. The hash of the block\nwill be null if the _meta field has a block constraint that asks for\na block number. It will be filled if the _meta field has no block constraint\nand therefore asks for the latest  block\n"
  block: _Block_!

  """
  The deployment ID
  """
  deployment: String!

  """
  If `true`, the subgraph encountered indexing errors at some past block
  """
  hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
  """
  Data will be returned even if the subgraph has indexing errors
  """
  allow

  """
  If the subgraph has indexing errors, data will be omitted. The default.
  """
  deny
}
