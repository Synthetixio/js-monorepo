// !!! DO NOT EDIT !!! Automatically generated file

export const address = '0xc174573620632f76e4C96Cc4bc8e999491e4ADe8';
export const abi = [
  'error AccountNotFound(uint128 accountId)',
  'error EmptyDistribution()',
  'error IneligibleForLiquidation(uint256 collateralValue, int256 debt, uint256 currentCRatio, uint256 cratio)',
  'error InsufficientMappedAmount(int256 scaleModifier)',
  'error InvalidParameter(string parameter, string reason)',
  'error MarketNotFound(uint128 marketId)',
  'error MismatchAssociatedSystemKind(bytes32 expected, bytes32 actual)',
  'error MustBeVaultLiquidated()',
  'error OverflowInt128ToUint128()',
  'error OverflowInt256ToInt128()',
  'error OverflowInt256ToUint256()',
  'error OverflowUint128ToInt128()',
  'error OverflowUint256ToInt256()',
  'error OverflowUint256ToUint128()',
  'event Liquidation(uint128 indexed accountId, uint128 indexed poolId, address indexed collateralType, tuple(uint256 debtLiquidated, uint256 collateralLiquidated, uint256 amountRewarded) liquidationData, uint128 liquidateAsAccountId, address sender)',
  'event VaultLiquidation(uint128 indexed poolId, address indexed collateralType, tuple(uint256 debtLiquidated, uint256 collateralLiquidated, uint256 amountRewarded) liquidationData, uint128 liquidateAsAccountId, address sender)',
  'function isPositionLiquidatable(uint128 accountId, uint128 poolId, address collateralType) returns (bool)',
  'function isVaultLiquidatable(uint128 poolId, address collateralType) returns (bool)',
  'function liquidate(uint128 accountId, uint128 poolId, address collateralType, uint128 liquidateAsAccountId) returns (tuple(uint256 debtLiquidated, uint256 collateralLiquidated, uint256 amountRewarded) liquidationData)',
  'function liquidateVault(uint128 poolId, address collateralType, uint128 liquidateAsAccountId, uint256 maxUsd) returns (tuple(uint256 debtLiquidated, uint256 collateralLiquidated, uint256 amountRewarded) liquidationData)',
];
export const name = 'LiquidationModule';
export const source = 'contracts/modules/core/LiquidationModule.sol';
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from 'ethers';
import type { FunctionFragment, Result, EventFragment } from '@ethersproject/abi';
import type { Listener, Provider } from '@ethersproject/providers';
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from './common';

export interface LiquidationModuleInterface extends utils.Interface {
  functions: {
    'isPositionLiquidatable(uint128,uint128,address)': FunctionFragment;
    'isVaultLiquidatable(uint128,address)': FunctionFragment;
    'liquidate(uint128,uint128,address,uint128)': FunctionFragment;
    'liquidateVault(uint128,address,uint128,uint256)': FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | 'isPositionLiquidatable'
      | 'isVaultLiquidatable'
      | 'liquidate'
      | 'liquidateVault'
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: 'isPositionLiquidatable',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: 'isVaultLiquidatable',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: 'liquidate',
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: 'liquidateVault',
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;

  decodeFunctionResult(functionFragment: 'isPositionLiquidatable', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'isVaultLiquidatable', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'liquidate', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'liquidateVault', data: BytesLike): Result;

  events: {
    'Liquidation(uint128,uint128,address,tuple,uint128,address)': EventFragment;
    'VaultLiquidation(uint128,address,tuple,uint128,address)': EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: 'Liquidation'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'VaultLiquidation'): EventFragment;
}

export interface LiquidationEventObject {
  accountId: BigNumber;
  poolId: BigNumber;
  collateralType: string;
  liquidationData: [BigNumber, BigNumber, BigNumber] & {
    debtLiquidated: BigNumber;
    collateralLiquidated: BigNumber;
    amountRewarded: BigNumber;
  };
  liquidateAsAccountId: BigNumber;
  sender: string;
}
export type LiquidationEvent = TypedEvent<
  [
    BigNumber,
    BigNumber,
    string,
    [BigNumber, BigNumber, BigNumber] & {
      debtLiquidated: BigNumber;
      collateralLiquidated: BigNumber;
      amountRewarded: BigNumber;
    },
    BigNumber,
    string
  ],
  LiquidationEventObject
>;

export type LiquidationEventFilter = TypedEventFilter<LiquidationEvent>;

export interface VaultLiquidationEventObject {
  poolId: BigNumber;
  collateralType: string;
  liquidationData: [BigNumber, BigNumber, BigNumber] & {
    debtLiquidated: BigNumber;
    collateralLiquidated: BigNumber;
    amountRewarded: BigNumber;
  };
  liquidateAsAccountId: BigNumber;
  sender: string;
}
export type VaultLiquidationEvent = TypedEvent<
  [
    BigNumber,
    string,
    [BigNumber, BigNumber, BigNumber] & {
      debtLiquidated: BigNumber;
      collateralLiquidated: BigNumber;
      amountRewarded: BigNumber;
    },
    BigNumber,
    string
  ],
  VaultLiquidationEventObject
>;

export type VaultLiquidationEventFilter = TypedEventFilter<VaultLiquidationEvent>;

export interface LiquidationModule extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: LiquidationModuleInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    isPositionLiquidatable(
      accountId: PromiseOrValue<BigNumberish>,
      poolId: PromiseOrValue<BigNumberish>,
      collateralType: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    isVaultLiquidatable(
      poolId: PromiseOrValue<BigNumberish>,
      collateralType: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    liquidate(
      accountId: PromiseOrValue<BigNumberish>,
      poolId: PromiseOrValue<BigNumberish>,
      collateralType: PromiseOrValue<string>,
      liquidateAsAccountId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    liquidateVault(
      poolId: PromiseOrValue<BigNumberish>,
      collateralType: PromiseOrValue<string>,
      liquidateAsAccountId: PromiseOrValue<BigNumberish>,
      maxUsd: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;
  };

  isPositionLiquidatable(
    accountId: PromiseOrValue<BigNumberish>,
    poolId: PromiseOrValue<BigNumberish>,
    collateralType: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  isVaultLiquidatable(
    poolId: PromiseOrValue<BigNumberish>,
    collateralType: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  liquidate(
    accountId: PromiseOrValue<BigNumberish>,
    poolId: PromiseOrValue<BigNumberish>,
    collateralType: PromiseOrValue<string>,
    liquidateAsAccountId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  liquidateVault(
    poolId: PromiseOrValue<BigNumberish>,
    collateralType: PromiseOrValue<string>,
    liquidateAsAccountId: PromiseOrValue<BigNumberish>,
    maxUsd: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    isPositionLiquidatable(
      accountId: PromiseOrValue<BigNumberish>,
      poolId: PromiseOrValue<BigNumberish>,
      collateralType: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    isVaultLiquidatable(
      poolId: PromiseOrValue<BigNumberish>,
      collateralType: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    liquidate(
      accountId: PromiseOrValue<BigNumberish>,
      poolId: PromiseOrValue<BigNumberish>,
      collateralType: PromiseOrValue<string>,
      liquidateAsAccountId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        debtLiquidated: BigNumber;
        collateralLiquidated: BigNumber;
        amountRewarded: BigNumber;
      }
    >;

    liquidateVault(
      poolId: PromiseOrValue<BigNumberish>,
      collateralType: PromiseOrValue<string>,
      liquidateAsAccountId: PromiseOrValue<BigNumberish>,
      maxUsd: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        debtLiquidated: BigNumber;
        collateralLiquidated: BigNumber;
        amountRewarded: BigNumber;
      }
    >;
  };

  filters: {
    'Liquidation(uint128,uint128,address,tuple,uint128,address)'(
      accountId?: PromiseOrValue<BigNumberish> | null,
      poolId?: PromiseOrValue<BigNumberish> | null,
      collateralType?: PromiseOrValue<string> | null,
      liquidationData?: null,
      liquidateAsAccountId?: null,
      sender?: null
    ): LiquidationEventFilter;
    Liquidation(
      accountId?: PromiseOrValue<BigNumberish> | null,
      poolId?: PromiseOrValue<BigNumberish> | null,
      collateralType?: PromiseOrValue<string> | null,
      liquidationData?: null,
      liquidateAsAccountId?: null,
      sender?: null
    ): LiquidationEventFilter;

    'VaultLiquidation(uint128,address,tuple,uint128,address)'(
      poolId?: PromiseOrValue<BigNumberish> | null,
      collateralType?: PromiseOrValue<string> | null,
      liquidationData?: null,
      liquidateAsAccountId?: null,
      sender?: null
    ): VaultLiquidationEventFilter;
    VaultLiquidation(
      poolId?: PromiseOrValue<BigNumberish> | null,
      collateralType?: PromiseOrValue<string> | null,
      liquidationData?: null,
      liquidateAsAccountId?: null,
      sender?: null
    ): VaultLiquidationEventFilter;
  };

  estimateGas: {
    isPositionLiquidatable(
      accountId: PromiseOrValue<BigNumberish>,
      poolId: PromiseOrValue<BigNumberish>,
      collateralType: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    isVaultLiquidatable(
      poolId: PromiseOrValue<BigNumberish>,
      collateralType: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    liquidate(
      accountId: PromiseOrValue<BigNumberish>,
      poolId: PromiseOrValue<BigNumberish>,
      collateralType: PromiseOrValue<string>,
      liquidateAsAccountId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    liquidateVault(
      poolId: PromiseOrValue<BigNumberish>,
      collateralType: PromiseOrValue<string>,
      liquidateAsAccountId: PromiseOrValue<BigNumberish>,
      maxUsd: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    isPositionLiquidatable(
      accountId: PromiseOrValue<BigNumberish>,
      poolId: PromiseOrValue<BigNumberish>,
      collateralType: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    isVaultLiquidatable(
      poolId: PromiseOrValue<BigNumberish>,
      collateralType: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    liquidate(
      accountId: PromiseOrValue<BigNumberish>,
      poolId: PromiseOrValue<BigNumberish>,
      collateralType: PromiseOrValue<string>,
      liquidateAsAccountId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    liquidateVault(
      poolId: PromiseOrValue<BigNumberish>,
      collateralType: PromiseOrValue<string>,
      liquidateAsAccountId: PromiseOrValue<BigNumberish>,
      maxUsd: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;
  };
}
