/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from 'ethers';
import type { FunctionFragment, Result, EventFragment } from '@ethersproject/abi';
import type { Listener, Provider } from '@ethersproject/providers';
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from './common';

export interface IssuerAbiTypesInterface extends utils.Interface {
  functions: {
    'CONTRACT_NAME()': FunctionFragment;
    'acceptOwnership()': FunctionFragment;
    'addSynth(address)': FunctionFragment;
    'addSynths(address[])': FunctionFragment;
    'allNetworksDebtInfo()': FunctionFragment;
    'anySynthOrSNXRateIsInvalid()': FunctionFragment;
    'availableCurrencyKeys()': FunctionFragment;
    'availableSynthCount()': FunctionFragment;
    'availableSynths(uint256)': FunctionFragment;
    'burnForRedemption(address,address,uint256)': FunctionFragment;
    'burnSynths(address,uint256)': FunctionFragment;
    'burnSynthsOnBehalf(address,address,uint256)': FunctionFragment;
    'burnSynthsToTarget(address)': FunctionFragment;
    'burnSynthsToTargetOnBehalf(address,address)': FunctionFragment;
    'burnSynthsWithoutDebt(bytes32,address,uint256)': FunctionFragment;
    'canBurnSynths(address)': FunctionFragment;
    'collateral(address)': FunctionFragment;
    'collateralisationRatio(address)': FunctionFragment;
    'collateralisationRatioAndAnyRatesInvalid(address)': FunctionFragment;
    'debtBalanceOf(address,bytes32)': FunctionFragment;
    'getSynths(bytes32[])': FunctionFragment;
    'isResolverCached()': FunctionFragment;
    'issuanceRatio()': FunctionFragment;
    'issueMaxSynths(address)': FunctionFragment;
    'issueMaxSynthsOnBehalf(address,address)': FunctionFragment;
    'issueSynths(address,uint256)': FunctionFragment;
    'issueSynthsOnBehalf(address,address,uint256)': FunctionFragment;
    'issueSynthsWithoutDebt(bytes32,address,uint256)': FunctionFragment;
    'lastIssueEvent(address)': FunctionFragment;
    'liquidateAccount(address,bool)': FunctionFragment;
    'maxIssuableSynths(address)': FunctionFragment;
    'minimumStakeTime()': FunctionFragment;
    'nominateNewOwner(address)': FunctionFragment;
    'nominatedOwner()': FunctionFragment;
    'owner()': FunctionFragment;
    'rebuildCache()': FunctionFragment;
    'remainingIssuableSynths(address)': FunctionFragment;
    'removeSynth(bytes32)': FunctionFragment;
    'removeSynths(bytes32[])': FunctionFragment;
    'resolver()': FunctionFragment;
    'resolverAddressesRequired()': FunctionFragment;
    'setCurrentPeriodId(uint128)': FunctionFragment;
    'synths(bytes32)': FunctionFragment;
    'synthsByAddress(address)': FunctionFragment;
    'totalIssuedSynths(bytes32,bool)': FunctionFragment;
    'transferableSynthetixAndAnyRateIsInvalid(address,uint256)': FunctionFragment;
    'upgradeCollateralShort(address,uint256)': FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | 'CONTRACT_NAME'
      | 'acceptOwnership'
      | 'addSynth'
      | 'addSynths'
      | 'allNetworksDebtInfo'
      | 'anySynthOrSNXRateIsInvalid'
      | 'availableCurrencyKeys'
      | 'availableSynthCount'
      | 'availableSynths'
      | 'burnForRedemption'
      | 'burnSynths'
      | 'burnSynthsOnBehalf'
      | 'burnSynthsToTarget'
      | 'burnSynthsToTargetOnBehalf'
      | 'burnSynthsWithoutDebt'
      | 'canBurnSynths'
      | 'collateral'
      | 'collateralisationRatio'
      | 'collateralisationRatioAndAnyRatesInvalid'
      | 'debtBalanceOf'
      | 'getSynths'
      | 'isResolverCached'
      | 'issuanceRatio'
      | 'issueMaxSynths'
      | 'issueMaxSynthsOnBehalf'
      | 'issueSynths'
      | 'issueSynthsOnBehalf'
      | 'issueSynthsWithoutDebt'
      | 'lastIssueEvent'
      | 'liquidateAccount'
      | 'maxIssuableSynths'
      | 'minimumStakeTime'
      | 'nominateNewOwner'
      | 'nominatedOwner'
      | 'owner'
      | 'rebuildCache'
      | 'remainingIssuableSynths'
      | 'removeSynth'
      | 'removeSynths'
      | 'resolver'
      | 'resolverAddressesRequired'
      | 'setCurrentPeriodId'
      | 'synths'
      | 'synthsByAddress'
      | 'totalIssuedSynths'
      | 'transferableSynthetixAndAnyRateIsInvalid'
      | 'upgradeCollateralShort'
  ): FunctionFragment;

  encodeFunctionData(functionFragment: 'CONTRACT_NAME', values?: undefined): string;
  encodeFunctionData(functionFragment: 'acceptOwnership', values?: undefined): string;
  encodeFunctionData(functionFragment: 'addSynth', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'addSynths', values: [PromiseOrValue<string>[]]): string;
  encodeFunctionData(functionFragment: 'allNetworksDebtInfo', values?: undefined): string;
  encodeFunctionData(functionFragment: 'anySynthOrSNXRateIsInvalid', values?: undefined): string;
  encodeFunctionData(functionFragment: 'availableCurrencyKeys', values?: undefined): string;
  encodeFunctionData(functionFragment: 'availableSynthCount', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'availableSynths',
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: 'burnForRedemption',
    values: [PromiseOrValue<string>, PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: 'burnSynths',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: 'burnSynthsOnBehalf',
    values: [PromiseOrValue<string>, PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: 'burnSynthsToTarget',
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: 'burnSynthsToTargetOnBehalf',
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: 'burnSynthsWithoutDebt',
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(functionFragment: 'canBurnSynths', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'collateral', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'collateralisationRatio',
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: 'collateralisationRatioAndAnyRatesInvalid',
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: 'debtBalanceOf',
    values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(functionFragment: 'getSynths', values: [PromiseOrValue<BytesLike>[]]): string;
  encodeFunctionData(functionFragment: 'isResolverCached', values?: undefined): string;
  encodeFunctionData(functionFragment: 'issuanceRatio', values?: undefined): string;
  encodeFunctionData(functionFragment: 'issueMaxSynths', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'issueMaxSynthsOnBehalf',
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: 'issueSynths',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: 'issueSynthsOnBehalf',
    values: [PromiseOrValue<string>, PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: 'issueSynthsWithoutDebt',
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(functionFragment: 'lastIssueEvent', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'liquidateAccount',
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: 'maxIssuableSynths',
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(functionFragment: 'minimumStakeTime', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'nominateNewOwner',
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(functionFragment: 'nominatedOwner', values?: undefined): string;
  encodeFunctionData(functionFragment: 'owner', values?: undefined): string;
  encodeFunctionData(functionFragment: 'rebuildCache', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'remainingIssuableSynths',
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(functionFragment: 'removeSynth', values: [PromiseOrValue<BytesLike>]): string;
  encodeFunctionData(
    functionFragment: 'removeSynths',
    values: [PromiseOrValue<BytesLike>[]]
  ): string;
  encodeFunctionData(functionFragment: 'resolver', values?: undefined): string;
  encodeFunctionData(functionFragment: 'resolverAddressesRequired', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'setCurrentPeriodId',
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(functionFragment: 'synths', values: [PromiseOrValue<BytesLike>]): string;
  encodeFunctionData(functionFragment: 'synthsByAddress', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'totalIssuedSynths',
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: 'transferableSynthetixAndAnyRateIsInvalid',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: 'upgradeCollateralShort',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;

  decodeFunctionResult(functionFragment: 'CONTRACT_NAME', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'acceptOwnership', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'addSynth', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'addSynths', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'allNetworksDebtInfo', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'anySynthOrSNXRateIsInvalid', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'availableCurrencyKeys', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'availableSynthCount', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'availableSynths', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'burnForRedemption', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'burnSynths', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'burnSynthsOnBehalf', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'burnSynthsToTarget', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'burnSynthsToTargetOnBehalf', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'burnSynthsWithoutDebt', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'canBurnSynths', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'collateral', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'collateralisationRatio', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'collateralisationRatioAndAnyRatesInvalid',
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: 'debtBalanceOf', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getSynths', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'isResolverCached', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'issuanceRatio', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'issueMaxSynths', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'issueMaxSynthsOnBehalf', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'issueSynths', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'issueSynthsOnBehalf', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'issueSynthsWithoutDebt', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'lastIssueEvent', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'liquidateAccount', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'maxIssuableSynths', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'minimumStakeTime', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'nominateNewOwner', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'nominatedOwner', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'owner', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'rebuildCache', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'remainingIssuableSynths', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'removeSynth', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'removeSynths', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'resolver', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'resolverAddressesRequired', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setCurrentPeriodId', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'synths', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'synthsByAddress', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'totalIssuedSynths', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'transferableSynthetixAndAnyRateIsInvalid',
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: 'upgradeCollateralShort', data: BytesLike): Result;

  events: {
    'CacheUpdated(bytes32,address)': EventFragment;
    'OwnerChanged(address,address)': EventFragment;
    'OwnerNominated(address)': EventFragment;
    'SynthAdded(bytes32,address)': EventFragment;
    'SynthRemoved(bytes32,address)': EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: 'CacheUpdated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'OwnerChanged'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'OwnerNominated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'SynthAdded'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'SynthRemoved'): EventFragment;
}

export interface CacheUpdatedEventObject {
  name: string;
  destination: string;
}
export type CacheUpdatedEvent = TypedEvent<[string, string], CacheUpdatedEventObject>;

export type CacheUpdatedEventFilter = TypedEventFilter<CacheUpdatedEvent>;

export interface OwnerChangedEventObject {
  oldOwner: string;
  newOwner: string;
}
export type OwnerChangedEvent = TypedEvent<[string, string], OwnerChangedEventObject>;

export type OwnerChangedEventFilter = TypedEventFilter<OwnerChangedEvent>;

export interface OwnerNominatedEventObject {
  newOwner: string;
}
export type OwnerNominatedEvent = TypedEvent<[string], OwnerNominatedEventObject>;

export type OwnerNominatedEventFilter = TypedEventFilter<OwnerNominatedEvent>;

export interface SynthAddedEventObject {
  currencyKey: string;
  synth: string;
}
export type SynthAddedEvent = TypedEvent<[string, string], SynthAddedEventObject>;

export type SynthAddedEventFilter = TypedEventFilter<SynthAddedEvent>;

export interface SynthRemovedEventObject {
  currencyKey: string;
  synth: string;
}
export type SynthRemovedEvent = TypedEvent<[string, string], SynthRemovedEventObject>;

export type SynthRemovedEventFilter = TypedEventFilter<SynthRemovedEvent>;

export interface IssuerAbiTypes extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: IssuerAbiTypesInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    CONTRACT_NAME(overrides?: CallOverrides): Promise<[string]>;

    acceptOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    addSynth(
      synth: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    addSynths(
      synthsToAdd: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    allNetworksDebtInfo(overrides?: CallOverrides): Promise<
      [BigNumber, BigNumber, boolean] & {
        debt: BigNumber;
        sharesSupply: BigNumber;
        isStale: boolean;
      }
    >;

    anySynthOrSNXRateIsInvalid(
      overrides?: CallOverrides
    ): Promise<[boolean] & { anyRateInvalid: boolean }>;

    availableCurrencyKeys(overrides?: CallOverrides): Promise<[string[]]>;

    availableSynthCount(overrides?: CallOverrides): Promise<[BigNumber]>;

    availableSynths(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    burnForRedemption(
      deprecatedSynthProxy: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      balance: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    burnSynths(
      from: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    burnSynthsOnBehalf(
      burnForAddress: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    burnSynthsToTarget(
      from: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    burnSynthsToTargetOnBehalf(
      burnForAddress: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    burnSynthsWithoutDebt(
      currencyKey: PromiseOrValue<BytesLike>,
      from: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    canBurnSynths(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;

    collateral(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber]>;

    collateralisationRatio(
      _issuer: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { cratio: BigNumber }>;

    collateralisationRatioAndAnyRatesInvalid(
      _issuer: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber, boolean] & { cratio: BigNumber; anyRateIsInvalid: boolean }>;

    debtBalanceOf(
      _issuer: PromiseOrValue<string>,
      currencyKey: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { debtBalance: BigNumber }>;

    getSynths(
      currencyKeys: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides
    ): Promise<[string[]]>;

    isResolverCached(overrides?: CallOverrides): Promise<[boolean]>;

    issuanceRatio(overrides?: CallOverrides): Promise<[BigNumber]>;

    issueMaxSynths(
      from: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    issueMaxSynthsOnBehalf(
      issueForAddress: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    issueSynths(
      from: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    issueSynthsOnBehalf(
      issueForAddress: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    issueSynthsWithoutDebt(
      currencyKey: PromiseOrValue<BytesLike>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    lastIssueEvent(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    liquidateAccount(
      account: PromiseOrValue<string>,
      isSelfLiquidation: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    maxIssuableSynths(
      _issuer: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    minimumStakeTime(overrides?: CallOverrides): Promise<[BigNumber]>;

    nominateNewOwner(
      _owner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    nominatedOwner(overrides?: CallOverrides): Promise<[string]>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    rebuildCache(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    remainingIssuableSynths(
      _issuer: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        maxIssuable: BigNumber;
        alreadyIssued: BigNumber;
        totalSystemDebt: BigNumber;
      }
    >;

    removeSynth(
      currencyKey: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    removeSynths(
      currencyKeys: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    resolver(overrides?: CallOverrides): Promise<[string]>;

    resolverAddressesRequired(
      overrides?: CallOverrides
    ): Promise<[string[]] & { addresses: string[] }>;

    setCurrentPeriodId(
      periodId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    synths(arg0: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[string]>;

    synthsByAddress(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[string]>;

    totalIssuedSynths(
      currencyKey: PromiseOrValue<BytesLike>,
      excludeOtherCollateral: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { totalIssued: BigNumber }>;

    transferableSynthetixAndAnyRateIsInvalid(
      account: PromiseOrValue<string>,
      balance: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, boolean] & {
        transferable: BigNumber;
        anyRateIsInvalid: boolean;
      }
    >;

    upgradeCollateralShort(
      short: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;
  };

  CONTRACT_NAME(overrides?: CallOverrides): Promise<string>;

  acceptOwnership(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  addSynth(
    synth: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  addSynths(
    synthsToAdd: PromiseOrValue<string>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  allNetworksDebtInfo(overrides?: CallOverrides): Promise<
    [BigNumber, BigNumber, boolean] & {
      debt: BigNumber;
      sharesSupply: BigNumber;
      isStale: boolean;
    }
  >;

  anySynthOrSNXRateIsInvalid(overrides?: CallOverrides): Promise<boolean>;

  availableCurrencyKeys(overrides?: CallOverrides): Promise<string[]>;

  availableSynthCount(overrides?: CallOverrides): Promise<BigNumber>;

  availableSynths(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<string>;

  burnForRedemption(
    deprecatedSynthProxy: PromiseOrValue<string>,
    account: PromiseOrValue<string>,
    balance: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  burnSynths(
    from: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  burnSynthsOnBehalf(
    burnForAddress: PromiseOrValue<string>,
    from: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  burnSynthsToTarget(
    from: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  burnSynthsToTargetOnBehalf(
    burnForAddress: PromiseOrValue<string>,
    from: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  burnSynthsWithoutDebt(
    currencyKey: PromiseOrValue<BytesLike>,
    from: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  canBurnSynths(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

  collateral(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

  collateralisationRatio(
    _issuer: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  collateralisationRatioAndAnyRatesInvalid(
    _issuer: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<[BigNumber, boolean] & { cratio: BigNumber; anyRateIsInvalid: boolean }>;

  debtBalanceOf(
    _issuer: PromiseOrValue<string>,
    currencyKey: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getSynths(
    currencyKeys: PromiseOrValue<BytesLike>[],
    overrides?: CallOverrides
  ): Promise<string[]>;

  isResolverCached(overrides?: CallOverrides): Promise<boolean>;

  issuanceRatio(overrides?: CallOverrides): Promise<BigNumber>;

  issueMaxSynths(
    from: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  issueMaxSynthsOnBehalf(
    issueForAddress: PromiseOrValue<string>,
    from: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  issueSynths(
    from: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  issueSynthsOnBehalf(
    issueForAddress: PromiseOrValue<string>,
    from: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  issueSynthsWithoutDebt(
    currencyKey: PromiseOrValue<BytesLike>,
    to: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  lastIssueEvent(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

  liquidateAccount(
    account: PromiseOrValue<string>,
    isSelfLiquidation: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  maxIssuableSynths(_issuer: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

  minimumStakeTime(overrides?: CallOverrides): Promise<BigNumber>;

  nominateNewOwner(
    _owner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  nominatedOwner(overrides?: CallOverrides): Promise<string>;

  owner(overrides?: CallOverrides): Promise<string>;

  rebuildCache(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  remainingIssuableSynths(
    _issuer: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, BigNumber] & {
      maxIssuable: BigNumber;
      alreadyIssued: BigNumber;
      totalSystemDebt: BigNumber;
    }
  >;

  removeSynth(
    currencyKey: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  removeSynths(
    currencyKeys: PromiseOrValue<BytesLike>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  resolver(overrides?: CallOverrides): Promise<string>;

  resolverAddressesRequired(overrides?: CallOverrides): Promise<string[]>;

  setCurrentPeriodId(
    periodId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  synths(arg0: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;

  synthsByAddress(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string>;

  totalIssuedSynths(
    currencyKey: PromiseOrValue<BytesLike>,
    excludeOtherCollateral: PromiseOrValue<boolean>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  transferableSynthetixAndAnyRateIsInvalid(
    account: PromiseOrValue<string>,
    balance: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, boolean] & {
      transferable: BigNumber;
      anyRateIsInvalid: boolean;
    }
  >;

  upgradeCollateralShort(
    short: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    CONTRACT_NAME(overrides?: CallOverrides): Promise<string>;

    acceptOwnership(overrides?: CallOverrides): Promise<void>;

    addSynth(synth: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    addSynths(synthsToAdd: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<void>;

    allNetworksDebtInfo(overrides?: CallOverrides): Promise<
      [BigNumber, BigNumber, boolean] & {
        debt: BigNumber;
        sharesSupply: BigNumber;
        isStale: boolean;
      }
    >;

    anySynthOrSNXRateIsInvalid(overrides?: CallOverrides): Promise<boolean>;

    availableCurrencyKeys(overrides?: CallOverrides): Promise<string[]>;

    availableSynthCount(overrides?: CallOverrides): Promise<BigNumber>;

    availableSynths(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<string>;

    burnForRedemption(
      deprecatedSynthProxy: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      balance: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    burnSynths(
      from: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    burnSynthsOnBehalf(
      burnForAddress: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    burnSynthsToTarget(from: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    burnSynthsToTargetOnBehalf(
      burnForAddress: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    burnSynthsWithoutDebt(
      currencyKey: PromiseOrValue<BytesLike>,
      from: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    canBurnSynths(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

    collateral(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    collateralisationRatio(
      _issuer: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    collateralisationRatioAndAnyRatesInvalid(
      _issuer: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber, boolean] & { cratio: BigNumber; anyRateIsInvalid: boolean }>;

    debtBalanceOf(
      _issuer: PromiseOrValue<string>,
      currencyKey: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getSynths(
      currencyKeys: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides
    ): Promise<string[]>;

    isResolverCached(overrides?: CallOverrides): Promise<boolean>;

    issuanceRatio(overrides?: CallOverrides): Promise<BigNumber>;

    issueMaxSynths(from: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    issueMaxSynthsOnBehalf(
      issueForAddress: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    issueSynths(
      from: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    issueSynthsOnBehalf(
      issueForAddress: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    issueSynthsWithoutDebt(
      currencyKey: PromiseOrValue<BytesLike>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    lastIssueEvent(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    liquidateAccount(
      account: PromiseOrValue<string>,
      isSelfLiquidation: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & {
        totalRedeemed: BigNumber;
        amountToLiquidate: BigNumber;
      }
    >;

    maxIssuableSynths(
      _issuer: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    minimumStakeTime(overrides?: CallOverrides): Promise<BigNumber>;

    nominateNewOwner(_owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    nominatedOwner(overrides?: CallOverrides): Promise<string>;

    owner(overrides?: CallOverrides): Promise<string>;

    rebuildCache(overrides?: CallOverrides): Promise<void>;

    remainingIssuableSynths(
      _issuer: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        maxIssuable: BigNumber;
        alreadyIssued: BigNumber;
        totalSystemDebt: BigNumber;
      }
    >;

    removeSynth(currencyKey: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<void>;

    removeSynths(
      currencyKeys: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides
    ): Promise<void>;

    resolver(overrides?: CallOverrides): Promise<string>;

    resolverAddressesRequired(overrides?: CallOverrides): Promise<string[]>;

    setCurrentPeriodId(
      periodId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    synths(arg0: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;

    synthsByAddress(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string>;

    totalIssuedSynths(
      currencyKey: PromiseOrValue<BytesLike>,
      excludeOtherCollateral: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    transferableSynthetixAndAnyRateIsInvalid(
      account: PromiseOrValue<string>,
      balance: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, boolean] & {
        transferable: BigNumber;
        anyRateIsInvalid: boolean;
      }
    >;

    upgradeCollateralShort(
      short: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    'CacheUpdated(bytes32,address)'(name?: null, destination?: null): CacheUpdatedEventFilter;
    CacheUpdated(name?: null, destination?: null): CacheUpdatedEventFilter;

    'OwnerChanged(address,address)'(oldOwner?: null, newOwner?: null): OwnerChangedEventFilter;
    OwnerChanged(oldOwner?: null, newOwner?: null): OwnerChangedEventFilter;

    'OwnerNominated(address)'(newOwner?: null): OwnerNominatedEventFilter;
    OwnerNominated(newOwner?: null): OwnerNominatedEventFilter;

    'SynthAdded(bytes32,address)'(currencyKey?: null, synth?: null): SynthAddedEventFilter;
    SynthAdded(currencyKey?: null, synth?: null): SynthAddedEventFilter;

    'SynthRemoved(bytes32,address)'(currencyKey?: null, synth?: null): SynthRemovedEventFilter;
    SynthRemoved(currencyKey?: null, synth?: null): SynthRemovedEventFilter;
  };

  estimateGas: {
    CONTRACT_NAME(overrides?: CallOverrides): Promise<BigNumber>;

    acceptOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    addSynth(
      synth: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    addSynths(
      synthsToAdd: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    allNetworksDebtInfo(overrides?: CallOverrides): Promise<BigNumber>;

    anySynthOrSNXRateIsInvalid(overrides?: CallOverrides): Promise<BigNumber>;

    availableCurrencyKeys(overrides?: CallOverrides): Promise<BigNumber>;

    availableSynthCount(overrides?: CallOverrides): Promise<BigNumber>;

    availableSynths(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    burnForRedemption(
      deprecatedSynthProxy: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      balance: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    burnSynths(
      from: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    burnSynthsOnBehalf(
      burnForAddress: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    burnSynthsToTarget(
      from: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    burnSynthsToTargetOnBehalf(
      burnForAddress: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    burnSynthsWithoutDebt(
      currencyKey: PromiseOrValue<BytesLike>,
      from: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    canBurnSynths(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    collateral(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    collateralisationRatio(
      _issuer: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    collateralisationRatioAndAnyRatesInvalid(
      _issuer: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    debtBalanceOf(
      _issuer: PromiseOrValue<string>,
      currencyKey: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getSynths(
      currencyKeys: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isResolverCached(overrides?: CallOverrides): Promise<BigNumber>;

    issuanceRatio(overrides?: CallOverrides): Promise<BigNumber>;

    issueMaxSynths(
      from: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    issueMaxSynthsOnBehalf(
      issueForAddress: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    issueSynths(
      from: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    issueSynthsOnBehalf(
      issueForAddress: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    issueSynthsWithoutDebt(
      currencyKey: PromiseOrValue<BytesLike>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    lastIssueEvent(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    liquidateAccount(
      account: PromiseOrValue<string>,
      isSelfLiquidation: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    maxIssuableSynths(
      _issuer: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    minimumStakeTime(overrides?: CallOverrides): Promise<BigNumber>;

    nominateNewOwner(
      _owner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    nominatedOwner(overrides?: CallOverrides): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    rebuildCache(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    remainingIssuableSynths(
      _issuer: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    removeSynth(
      currencyKey: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    removeSynths(
      currencyKeys: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    resolver(overrides?: CallOverrides): Promise<BigNumber>;

    resolverAddressesRequired(overrides?: CallOverrides): Promise<BigNumber>;

    setCurrentPeriodId(
      periodId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    synths(arg0: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber>;

    synthsByAddress(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    totalIssuedSynths(
      currencyKey: PromiseOrValue<BytesLike>,
      excludeOtherCollateral: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    transferableSynthetixAndAnyRateIsInvalid(
      account: PromiseOrValue<string>,
      balance: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    upgradeCollateralShort(
      short: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    CONTRACT_NAME(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    acceptOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    addSynth(
      synth: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    addSynths(
      synthsToAdd: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    allNetworksDebtInfo(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    anySynthOrSNXRateIsInvalid(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    availableCurrencyKeys(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    availableSynthCount(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    availableSynths(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    burnForRedemption(
      deprecatedSynthProxy: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      balance: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    burnSynths(
      from: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    burnSynthsOnBehalf(
      burnForAddress: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    burnSynthsToTarget(
      from: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    burnSynthsToTargetOnBehalf(
      burnForAddress: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    burnSynthsWithoutDebt(
      currencyKey: PromiseOrValue<BytesLike>,
      from: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    canBurnSynths(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    collateral(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    collateralisationRatio(
      _issuer: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    collateralisationRatioAndAnyRatesInvalid(
      _issuer: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    debtBalanceOf(
      _issuer: PromiseOrValue<string>,
      currencyKey: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getSynths(
      currencyKeys: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isResolverCached(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    issuanceRatio(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    issueMaxSynths(
      from: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    issueMaxSynthsOnBehalf(
      issueForAddress: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    issueSynths(
      from: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    issueSynthsOnBehalf(
      issueForAddress: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    issueSynthsWithoutDebt(
      currencyKey: PromiseOrValue<BytesLike>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    lastIssueEvent(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    liquidateAccount(
      account: PromiseOrValue<string>,
      isSelfLiquidation: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    maxIssuableSynths(
      _issuer: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    minimumStakeTime(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    nominateNewOwner(
      _owner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    nominatedOwner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    rebuildCache(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    remainingIssuableSynths(
      _issuer: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    removeSynth(
      currencyKey: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    removeSynths(
      currencyKeys: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    resolver(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    resolverAddressesRequired(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    setCurrentPeriodId(
      periodId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    synths(
      arg0: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    synthsByAddress(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    totalIssuedSynths(
      currencyKey: PromiseOrValue<BytesLike>,
      excludeOtherCollateral: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    transferableSynthetixAndAnyRateIsInvalid(
      account: PromiseOrValue<string>,
      balance: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    upgradeCollateralShort(
      short: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;
  };
}
