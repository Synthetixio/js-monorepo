// !!! DO NOT EDIT !!! Automatically generated file

export const name = 'ExchangeSettlementLib';
export const address = '0xAa5A3D7F04E15b22Eb3664B56310aA18A3527Ec7';
export const source = 'ExchangeSettlementLib';
export const abi = [
  'event ExchangeEntryAppended(address indexed account, bytes32 src, uint256 amount, bytes32 dest, uint256 amountReceived, uint256 exchangeFeeRate, uint256 roundIdForSrc, uint256 roundIdForDest)',
  'event ExchangeEntrySettled(address indexed from, bytes32 src, uint256 amount, bytes32 dest, uint256 reclaim, uint256 rebate, uint256 srcRoundIdAtPeriodEnd, uint256 destRoundIdAtPeriodEnd, uint256 exchangeTimestamp)',
  'function hasWaitingPeriodOrSettlementOwing(tuple(IExchangeState exchangeState, IExchangeRates exchangeRates, ICircuitBreaker circuitBreaker, IExchangerInternalDebtCache debtCache, IIssuer issuer, ISynthetix synthetix) resolvedAddresses, address account, bytes32 currencyKey, uint256 waitingPeriod) view returns (bool)',
  'function maxSecsLeftInWaitingPeriod(IExchangeState exchangeState, address account, bytes32 currencyKey, uint256 waitingPeriod) view returns (uint256)',
  'function settlementOwing(tuple(IExchangeState exchangeState, IExchangeRates exchangeRates, ICircuitBreaker circuitBreaker, IExchangerInternalDebtCache debtCache, IIssuer issuer, ISynthetix synthetix) resolvedAddresses, address account, bytes32 currencyKey, uint256 waitingPeriod) view returns (uint256 reclaimAmount, uint256 rebateAmount, uint256 numEntries, tuple(bytes32 src, uint256 amount, bytes32 dest, uint256 reclaim, uint256 rebate, uint256 srcRoundIdAtPeriodEnd, uint256 destRoundIdAtPeriodEnd, uint256 timestamp)[])',
];
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from 'ethers';
import type { FunctionFragment, Result, EventFragment } from '@ethersproject/abi';
import type { Listener, Provider } from '@ethersproject/providers';
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from './common';

export declare namespace ExchangeSettlementLib {
  export type ResolvedAddressesStruct = {
    exchangeState: PromiseOrValue<string>;
    exchangeRates: PromiseOrValue<string>;
    circuitBreaker: PromiseOrValue<string>;
    debtCache: PromiseOrValue<string>;
    issuer: PromiseOrValue<string>;
    synthetix: PromiseOrValue<string>;
  };

  export type ResolvedAddressesStructOutput = [string, string, string, string, string, string] & {
    exchangeState: string;
    exchangeRates: string;
    circuitBreaker: string;
    debtCache: string;
    issuer: string;
    synthetix: string;
  };
}

export declare namespace IExchanger {
  export type ExchangeEntrySettlementStruct = {
    src: PromiseOrValue<BytesLike>;
    amount: PromiseOrValue<BigNumberish>;
    dest: PromiseOrValue<BytesLike>;
    reclaim: PromiseOrValue<BigNumberish>;
    rebate: PromiseOrValue<BigNumberish>;
    srcRoundIdAtPeriodEnd: PromiseOrValue<BigNumberish>;
    destRoundIdAtPeriodEnd: PromiseOrValue<BigNumberish>;
    timestamp: PromiseOrValue<BigNumberish>;
  };

  export type ExchangeEntrySettlementStructOutput = [
    string,
    BigNumber,
    string,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    src: string;
    amount: BigNumber;
    dest: string;
    reclaim: BigNumber;
    rebate: BigNumber;
    srcRoundIdAtPeriodEnd: BigNumber;
    destRoundIdAtPeriodEnd: BigNumber;
    timestamp: BigNumber;
  };
}

export interface ExchangeSettlementLibInterface extends utils.Interface {
  functions: {
    'hasWaitingPeriodOrSettlementOwing((IExchangeState,IExchangeRates,ICircuitBreaker,IExchangerInternalDebtCache,IIssuer,ISynthetix),address,bytes32,uint256)': FunctionFragment;
    'maxSecsLeftInWaitingPeriod(IExchangeState,address,bytes32,uint256)': FunctionFragment;
    'settlementOwing((IExchangeState,IExchangeRates,ICircuitBreaker,IExchangerInternalDebtCache,IIssuer,ISynthetix),address,bytes32,uint256)': FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | 'hasWaitingPeriodOrSettlementOwing'
      | 'maxSecsLeftInWaitingPeriod'
      | 'settlementOwing'
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: 'hasWaitingPeriodOrSettlementOwing',
    values: [
      ExchangeSettlementLib.ResolvedAddressesStruct,
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: 'maxSecsLeftInWaitingPeriod',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: 'settlementOwing',
    values: [
      ExchangeSettlementLib.ResolvedAddressesStruct,
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;

  decodeFunctionResult(
    functionFragment: 'hasWaitingPeriodOrSettlementOwing',
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: 'maxSecsLeftInWaitingPeriod', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'settlementOwing', data: BytesLike): Result;

  events: {
    'ExchangeEntryAppended(address,bytes32,uint256,bytes32,uint256,uint256,uint256,uint256)': EventFragment;
    'ExchangeEntrySettled(address,bytes32,uint256,bytes32,uint256,uint256,uint256,uint256,uint256)': EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: 'ExchangeEntryAppended'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'ExchangeEntrySettled'): EventFragment;
}

export interface ExchangeEntryAppendedEventObject {
  account: string;
  src: string;
  amount: BigNumber;
  dest: string;
  amountReceived: BigNumber;
  exchangeFeeRate: BigNumber;
  roundIdForSrc: BigNumber;
  roundIdForDest: BigNumber;
}
export type ExchangeEntryAppendedEvent = TypedEvent<
  [string, string, BigNumber, string, BigNumber, BigNumber, BigNumber, BigNumber],
  ExchangeEntryAppendedEventObject
>;

export type ExchangeEntryAppendedEventFilter = TypedEventFilter<ExchangeEntryAppendedEvent>;

export interface ExchangeEntrySettledEventObject {
  from: string;
  src: string;
  amount: BigNumber;
  dest: string;
  reclaim: BigNumber;
  rebate: BigNumber;
  srcRoundIdAtPeriodEnd: BigNumber;
  destRoundIdAtPeriodEnd: BigNumber;
  exchangeTimestamp: BigNumber;
}
export type ExchangeEntrySettledEvent = TypedEvent<
  [string, string, BigNumber, string, BigNumber, BigNumber, BigNumber, BigNumber, BigNumber],
  ExchangeEntrySettledEventObject
>;

export type ExchangeEntrySettledEventFilter = TypedEventFilter<ExchangeEntrySettledEvent>;

export interface ExchangeSettlementLib extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: ExchangeSettlementLibInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    hasWaitingPeriodOrSettlementOwing(
      resolvedAddresses: ExchangeSettlementLib.ResolvedAddressesStruct,
      account: PromiseOrValue<string>,
      currencyKey: PromiseOrValue<BytesLike>,
      waitingPeriod: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    maxSecsLeftInWaitingPeriod(
      exchangeState: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      currencyKey: PromiseOrValue<BytesLike>,
      waitingPeriod: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    settlementOwing(
      resolvedAddresses: ExchangeSettlementLib.ResolvedAddressesStruct,
      account: PromiseOrValue<string>,
      currencyKey: PromiseOrValue<BytesLike>,
      waitingPeriod: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, IExchanger.ExchangeEntrySettlementStructOutput[]] & {
        reclaimAmount: BigNumber;
        rebateAmount: BigNumber;
        numEntries: BigNumber;
      }
    >;
  };

  hasWaitingPeriodOrSettlementOwing(
    resolvedAddresses: ExchangeSettlementLib.ResolvedAddressesStruct,
    account: PromiseOrValue<string>,
    currencyKey: PromiseOrValue<BytesLike>,
    waitingPeriod: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  maxSecsLeftInWaitingPeriod(
    exchangeState: PromiseOrValue<string>,
    account: PromiseOrValue<string>,
    currencyKey: PromiseOrValue<BytesLike>,
    waitingPeriod: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  settlementOwing(
    resolvedAddresses: ExchangeSettlementLib.ResolvedAddressesStruct,
    account: PromiseOrValue<string>,
    currencyKey: PromiseOrValue<BytesLike>,
    waitingPeriod: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, BigNumber, IExchanger.ExchangeEntrySettlementStructOutput[]] & {
      reclaimAmount: BigNumber;
      rebateAmount: BigNumber;
      numEntries: BigNumber;
    }
  >;

  callStatic: {
    hasWaitingPeriodOrSettlementOwing(
      resolvedAddresses: ExchangeSettlementLib.ResolvedAddressesStruct,
      account: PromiseOrValue<string>,
      currencyKey: PromiseOrValue<BytesLike>,
      waitingPeriod: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    maxSecsLeftInWaitingPeriod(
      exchangeState: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      currencyKey: PromiseOrValue<BytesLike>,
      waitingPeriod: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    settlementOwing(
      resolvedAddresses: ExchangeSettlementLib.ResolvedAddressesStruct,
      account: PromiseOrValue<string>,
      currencyKey: PromiseOrValue<BytesLike>,
      waitingPeriod: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, IExchanger.ExchangeEntrySettlementStructOutput[]] & {
        reclaimAmount: BigNumber;
        rebateAmount: BigNumber;
        numEntries: BigNumber;
      }
    >;
  };

  filters: {
    'ExchangeEntryAppended(address,bytes32,uint256,bytes32,uint256,uint256,uint256,uint256)'(
      account?: PromiseOrValue<string> | null,
      src?: null,
      amount?: null,
      dest?: null,
      amountReceived?: null,
      exchangeFeeRate?: null,
      roundIdForSrc?: null,
      roundIdForDest?: null
    ): ExchangeEntryAppendedEventFilter;
    ExchangeEntryAppended(
      account?: PromiseOrValue<string> | null,
      src?: null,
      amount?: null,
      dest?: null,
      amountReceived?: null,
      exchangeFeeRate?: null,
      roundIdForSrc?: null,
      roundIdForDest?: null
    ): ExchangeEntryAppendedEventFilter;

    'ExchangeEntrySettled(address,bytes32,uint256,bytes32,uint256,uint256,uint256,uint256,uint256)'(
      from?: PromiseOrValue<string> | null,
      src?: null,
      amount?: null,
      dest?: null,
      reclaim?: null,
      rebate?: null,
      srcRoundIdAtPeriodEnd?: null,
      destRoundIdAtPeriodEnd?: null,
      exchangeTimestamp?: null
    ): ExchangeEntrySettledEventFilter;
    ExchangeEntrySettled(
      from?: PromiseOrValue<string> | null,
      src?: null,
      amount?: null,
      dest?: null,
      reclaim?: null,
      rebate?: null,
      srcRoundIdAtPeriodEnd?: null,
      destRoundIdAtPeriodEnd?: null,
      exchangeTimestamp?: null
    ): ExchangeEntrySettledEventFilter;
  };

  estimateGas: {
    hasWaitingPeriodOrSettlementOwing(
      resolvedAddresses: ExchangeSettlementLib.ResolvedAddressesStruct,
      account: PromiseOrValue<string>,
      currencyKey: PromiseOrValue<BytesLike>,
      waitingPeriod: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    maxSecsLeftInWaitingPeriod(
      exchangeState: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      currencyKey: PromiseOrValue<BytesLike>,
      waitingPeriod: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    settlementOwing(
      resolvedAddresses: ExchangeSettlementLib.ResolvedAddressesStruct,
      account: PromiseOrValue<string>,
      currencyKey: PromiseOrValue<BytesLike>,
      waitingPeriod: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    hasWaitingPeriodOrSettlementOwing(
      resolvedAddresses: ExchangeSettlementLib.ResolvedAddressesStruct,
      account: PromiseOrValue<string>,
      currencyKey: PromiseOrValue<BytesLike>,
      waitingPeriod: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    maxSecsLeftInWaitingPeriod(
      exchangeState: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      currencyKey: PromiseOrValue<BytesLike>,
      waitingPeriod: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    settlementOwing(
      resolvedAddresses: ExchangeSettlementLib.ResolvedAddressesStruct,
      account: PromiseOrValue<string>,
      currencyKey: PromiseOrValue<BytesLike>,
      waitingPeriod: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;
  };
}
