/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from 'ethers';
import type { FunctionFragment, Result, EventFragment } from '@ethersproject/abi';
import type { Listener, Provider } from '@ethersproject/providers';
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from './common';

export interface CollateralManagerAbiInterface extends utils.Interface {
  functions: {
    'CONTRACT_NAME()': FunctionFragment;
    'acceptOwnership()': FunctionFragment;
    'addCollaterals(address[])': FunctionFragment;
    'addShortableSynths(bytes32[2][],bytes32[])': FunctionFragment;
    'addSynths(bytes32[],bytes32[])': FunctionFragment;
    'areShortableSynthsSet(bytes32[],bytes32[])': FunctionFragment;
    'areSynthsAndCurrenciesSet(bytes32[],bytes32[])': FunctionFragment;
    'baseBorrowRate()': FunctionFragment;
    'baseShortRate()': FunctionFragment;
    'decrementLongs(bytes32,uint256)': FunctionFragment;
    'decrementShorts(bytes32,uint256)': FunctionFragment;
    'exceedsDebtLimit(uint256,bytes32)': FunctionFragment;
    'getBorrowRate()': FunctionFragment;
    'getNewLoanId()': FunctionFragment;
    'getRatesAndTime(uint256)': FunctionFragment;
    'getShortRate(bytes32)': FunctionFragment;
    'getShortRatesAndTime(bytes32,uint256)': FunctionFragment;
    'hasAllCollaterals(address[])': FunctionFragment;
    'hasCollateral(address)': FunctionFragment;
    'incrementLongs(bytes32,uint256)': FunctionFragment;
    'incrementShorts(bytes32,uint256)': FunctionFragment;
    'isResolverCached()': FunctionFragment;
    'isSynthManaged(bytes32)': FunctionFragment;
    'lastPauseTime()': FunctionFragment;
    'long(bytes32)': FunctionFragment;
    'maxDebt()': FunctionFragment;
    'nominateNewOwner(address)': FunctionFragment;
    'nominatedOwner()': FunctionFragment;
    'owner()': FunctionFragment;
    'paused()': FunctionFragment;
    'rebuildCache()': FunctionFragment;
    'removeCollaterals(address[])': FunctionFragment;
    'removeShortableSynths(bytes32[])': FunctionFragment;
    'removeSynths(bytes32[],bytes32[])': FunctionFragment;
    'resolver()': FunctionFragment;
    'resolverAddressesRequired()': FunctionFragment;
    'setBaseBorrowRate(uint256)': FunctionFragment;
    'setBaseShortRate(uint256)': FunctionFragment;
    'setMaxDebt(uint256)': FunctionFragment;
    'setPaused(bool)': FunctionFragment;
    'setUtilisationMultiplier(uint256)': FunctionFragment;
    'short(bytes32)': FunctionFragment;
    'state()': FunctionFragment;
    'synthToInverseSynth(bytes32)': FunctionFragment;
    'synthsByKey(bytes32)': FunctionFragment;
    'totalLong()': FunctionFragment;
    'totalShort()': FunctionFragment;
    'updateBorrowRates(uint256)': FunctionFragment;
    'updateShortRates(bytes32,uint256)': FunctionFragment;
    'utilisationMultiplier()': FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | 'CONTRACT_NAME'
      | 'acceptOwnership'
      | 'addCollaterals'
      | 'addShortableSynths'
      | 'addSynths'
      | 'areShortableSynthsSet'
      | 'areSynthsAndCurrenciesSet'
      | 'baseBorrowRate'
      | 'baseShortRate'
      | 'decrementLongs'
      | 'decrementShorts'
      | 'exceedsDebtLimit'
      | 'getBorrowRate'
      | 'getNewLoanId'
      | 'getRatesAndTime'
      | 'getShortRate'
      | 'getShortRatesAndTime'
      | 'hasAllCollaterals'
      | 'hasCollateral'
      | 'incrementLongs'
      | 'incrementShorts'
      | 'isResolverCached'
      | 'isSynthManaged'
      | 'lastPauseTime'
      | 'long'
      | 'maxDebt'
      | 'nominateNewOwner'
      | 'nominatedOwner'
      | 'owner'
      | 'paused'
      | 'rebuildCache'
      | 'removeCollaterals'
      | 'removeShortableSynths'
      | 'removeSynths'
      | 'resolver'
      | 'resolverAddressesRequired'
      | 'setBaseBorrowRate'
      | 'setBaseShortRate'
      | 'setMaxDebt'
      | 'setPaused'
      | 'setUtilisationMultiplier'
      | 'short'
      | 'state'
      | 'synthToInverseSynth'
      | 'synthsByKey'
      | 'totalLong'
      | 'totalShort'
      | 'updateBorrowRates'
      | 'updateShortRates'
      | 'utilisationMultiplier'
  ): FunctionFragment;

  encodeFunctionData(functionFragment: 'CONTRACT_NAME', values?: undefined): string;
  encodeFunctionData(functionFragment: 'acceptOwnership', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'addCollaterals',
    values: [PromiseOrValue<string>[]]
  ): string;
  encodeFunctionData(
    functionFragment: 'addShortableSynths',
    values: [[PromiseOrValue<BytesLike>, PromiseOrValue<BytesLike>][], PromiseOrValue<BytesLike>[]]
  ): string;
  encodeFunctionData(
    functionFragment: 'addSynths',
    values: [PromiseOrValue<BytesLike>[], PromiseOrValue<BytesLike>[]]
  ): string;
  encodeFunctionData(
    functionFragment: 'areShortableSynthsSet',
    values: [PromiseOrValue<BytesLike>[], PromiseOrValue<BytesLike>[]]
  ): string;
  encodeFunctionData(
    functionFragment: 'areSynthsAndCurrenciesSet',
    values: [PromiseOrValue<BytesLike>[], PromiseOrValue<BytesLike>[]]
  ): string;
  encodeFunctionData(functionFragment: 'baseBorrowRate', values?: undefined): string;
  encodeFunctionData(functionFragment: 'baseShortRate', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'decrementLongs',
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: 'decrementShorts',
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: 'exceedsDebtLimit',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(functionFragment: 'getBorrowRate', values?: undefined): string;
  encodeFunctionData(functionFragment: 'getNewLoanId', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'getRatesAndTime',
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(functionFragment: 'getShortRate', values: [PromiseOrValue<BytesLike>]): string;
  encodeFunctionData(
    functionFragment: 'getShortRatesAndTime',
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: 'hasAllCollaterals',
    values: [PromiseOrValue<string>[]]
  ): string;
  encodeFunctionData(functionFragment: 'hasCollateral', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'incrementLongs',
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: 'incrementShorts',
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(functionFragment: 'isResolverCached', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'isSynthManaged',
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(functionFragment: 'lastPauseTime', values?: undefined): string;
  encodeFunctionData(functionFragment: 'long', values: [PromiseOrValue<BytesLike>]): string;
  encodeFunctionData(functionFragment: 'maxDebt', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'nominateNewOwner',
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(functionFragment: 'nominatedOwner', values?: undefined): string;
  encodeFunctionData(functionFragment: 'owner', values?: undefined): string;
  encodeFunctionData(functionFragment: 'paused', values?: undefined): string;
  encodeFunctionData(functionFragment: 'rebuildCache', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'removeCollaterals',
    values: [PromiseOrValue<string>[]]
  ): string;
  encodeFunctionData(
    functionFragment: 'removeShortableSynths',
    values: [PromiseOrValue<BytesLike>[]]
  ): string;
  encodeFunctionData(
    functionFragment: 'removeSynths',
    values: [PromiseOrValue<BytesLike>[], PromiseOrValue<BytesLike>[]]
  ): string;
  encodeFunctionData(functionFragment: 'resolver', values?: undefined): string;
  encodeFunctionData(functionFragment: 'resolverAddressesRequired', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'setBaseBorrowRate',
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: 'setBaseShortRate',
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: 'setMaxDebt',
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(functionFragment: 'setPaused', values: [PromiseOrValue<boolean>]): string;
  encodeFunctionData(
    functionFragment: 'setUtilisationMultiplier',
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(functionFragment: 'short', values: [PromiseOrValue<BytesLike>]): string;
  encodeFunctionData(functionFragment: 'state', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'synthToInverseSynth',
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(functionFragment: 'synthsByKey', values: [PromiseOrValue<BytesLike>]): string;
  encodeFunctionData(functionFragment: 'totalLong', values?: undefined): string;
  encodeFunctionData(functionFragment: 'totalShort', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'updateBorrowRates',
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: 'updateShortRates',
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(functionFragment: 'utilisationMultiplier', values?: undefined): string;

  decodeFunctionResult(functionFragment: 'CONTRACT_NAME', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'acceptOwnership', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'addCollaterals', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'addShortableSynths', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'addSynths', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'areShortableSynthsSet', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'areSynthsAndCurrenciesSet', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'baseBorrowRate', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'baseShortRate', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'decrementLongs', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'decrementShorts', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'exceedsDebtLimit', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getBorrowRate', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getNewLoanId', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getRatesAndTime', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getShortRate', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getShortRatesAndTime', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'hasAllCollaterals', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'hasCollateral', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'incrementLongs', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'incrementShorts', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'isResolverCached', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'isSynthManaged', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'lastPauseTime', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'long', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'maxDebt', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'nominateNewOwner', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'nominatedOwner', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'owner', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'paused', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'rebuildCache', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'removeCollaterals', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'removeShortableSynths', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'removeSynths', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'resolver', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'resolverAddressesRequired', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setBaseBorrowRate', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setBaseShortRate', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setMaxDebt', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setPaused', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setUtilisationMultiplier', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'short', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'state', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'synthToInverseSynth', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'synthsByKey', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'totalLong', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'totalShort', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'updateBorrowRates', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'updateShortRates', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'utilisationMultiplier', data: BytesLike): Result;

  events: {
    'BaseBorrowRateUpdated(uint256)': EventFragment;
    'BaseShortRateUpdated(uint256)': EventFragment;
    'CacheUpdated(bytes32,address)': EventFragment;
    'CollateralAdded(address)': EventFragment;
    'CollateralRemoved(address)': EventFragment;
    'LiquidationPenaltyUpdated(uint256)': EventFragment;
    'MaxDebtUpdated(uint256)': EventFragment;
    'OwnerChanged(address,address)': EventFragment;
    'OwnerNominated(address)': EventFragment;
    'PauseChanged(bool)': EventFragment;
    'ShortableSynthAdded(bytes32)': EventFragment;
    'ShortableSynthRemoved(bytes32)': EventFragment;
    'SynthAdded(bytes32)': EventFragment;
    'SynthRemoved(bytes32)': EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: 'BaseBorrowRateUpdated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'BaseShortRateUpdated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'CacheUpdated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'CollateralAdded'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'CollateralRemoved'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'LiquidationPenaltyUpdated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'MaxDebtUpdated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'OwnerChanged'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'OwnerNominated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'PauseChanged'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'ShortableSynthAdded'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'ShortableSynthRemoved'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'SynthAdded'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'SynthRemoved'): EventFragment;
}

export interface BaseBorrowRateUpdatedEventObject {
  baseBorrowRate: BigNumber;
}
export type BaseBorrowRateUpdatedEvent = TypedEvent<[BigNumber], BaseBorrowRateUpdatedEventObject>;

export type BaseBorrowRateUpdatedEventFilter = TypedEventFilter<BaseBorrowRateUpdatedEvent>;

export interface BaseShortRateUpdatedEventObject {
  baseShortRate: BigNumber;
}
export type BaseShortRateUpdatedEvent = TypedEvent<[BigNumber], BaseShortRateUpdatedEventObject>;

export type BaseShortRateUpdatedEventFilter = TypedEventFilter<BaseShortRateUpdatedEvent>;

export interface CacheUpdatedEventObject {
  name: string;
  destination: string;
}
export type CacheUpdatedEvent = TypedEvent<[string, string], CacheUpdatedEventObject>;

export type CacheUpdatedEventFilter = TypedEventFilter<CacheUpdatedEvent>;

export interface CollateralAddedEventObject {
  collateral: string;
}
export type CollateralAddedEvent = TypedEvent<[string], CollateralAddedEventObject>;

export type CollateralAddedEventFilter = TypedEventFilter<CollateralAddedEvent>;

export interface CollateralRemovedEventObject {
  collateral: string;
}
export type CollateralRemovedEvent = TypedEvent<[string], CollateralRemovedEventObject>;

export type CollateralRemovedEventFilter = TypedEventFilter<CollateralRemovedEvent>;

export interface LiquidationPenaltyUpdatedEventObject {
  liquidationPenalty: BigNumber;
}
export type LiquidationPenaltyUpdatedEvent = TypedEvent<
  [BigNumber],
  LiquidationPenaltyUpdatedEventObject
>;

export type LiquidationPenaltyUpdatedEventFilter = TypedEventFilter<LiquidationPenaltyUpdatedEvent>;

export interface MaxDebtUpdatedEventObject {
  maxDebt: BigNumber;
}
export type MaxDebtUpdatedEvent = TypedEvent<[BigNumber], MaxDebtUpdatedEventObject>;

export type MaxDebtUpdatedEventFilter = TypedEventFilter<MaxDebtUpdatedEvent>;

export interface OwnerChangedEventObject {
  oldOwner: string;
  newOwner: string;
}
export type OwnerChangedEvent = TypedEvent<[string, string], OwnerChangedEventObject>;

export type OwnerChangedEventFilter = TypedEventFilter<OwnerChangedEvent>;

export interface OwnerNominatedEventObject {
  newOwner: string;
}
export type OwnerNominatedEvent = TypedEvent<[string], OwnerNominatedEventObject>;

export type OwnerNominatedEventFilter = TypedEventFilter<OwnerNominatedEvent>;

export interface PauseChangedEventObject {
  isPaused: boolean;
}
export type PauseChangedEvent = TypedEvent<[boolean], PauseChangedEventObject>;

export type PauseChangedEventFilter = TypedEventFilter<PauseChangedEvent>;

export interface ShortableSynthAddedEventObject {
  synth: string;
}
export type ShortableSynthAddedEvent = TypedEvent<[string], ShortableSynthAddedEventObject>;

export type ShortableSynthAddedEventFilter = TypedEventFilter<ShortableSynthAddedEvent>;

export interface ShortableSynthRemovedEventObject {
  synth: string;
}
export type ShortableSynthRemovedEvent = TypedEvent<[string], ShortableSynthRemovedEventObject>;

export type ShortableSynthRemovedEventFilter = TypedEventFilter<ShortableSynthRemovedEvent>;

export interface SynthAddedEventObject {
  synth: string;
}
export type SynthAddedEvent = TypedEvent<[string], SynthAddedEventObject>;

export type SynthAddedEventFilter = TypedEventFilter<SynthAddedEvent>;

export interface SynthRemovedEventObject {
  synth: string;
}
export type SynthRemovedEvent = TypedEvent<[string], SynthRemovedEventObject>;

export type SynthRemovedEventFilter = TypedEventFilter<SynthRemovedEvent>;

export interface CollateralManagerAbi extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: CollateralManagerAbiInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    CONTRACT_NAME(overrides?: CallOverrides): Promise<[string]>;

    acceptOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    addCollaterals(
      collaterals: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    addShortableSynths(
      requiredSynthAndInverseNamesInResolver: [
        PromiseOrValue<BytesLike>,
        PromiseOrValue<BytesLike>
      ][],
      synthKeys: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    addSynths(
      synthNamesInResolver: PromiseOrValue<BytesLike>[],
      synthKeys: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    areShortableSynthsSet(
      requiredSynthNamesInResolver: PromiseOrValue<BytesLike>[],
      synthKeys: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    areSynthsAndCurrenciesSet(
      requiredSynthNamesInResolver: PromiseOrValue<BytesLike>[],
      synthKeys: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    baseBorrowRate(overrides?: CallOverrides): Promise<[BigNumber]>;

    baseShortRate(overrides?: CallOverrides): Promise<[BigNumber]>;

    decrementLongs(
      synth: PromiseOrValue<BytesLike>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    decrementShorts(
      synth: PromiseOrValue<BytesLike>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    exceedsDebtLimit(
      amount: PromiseOrValue<BigNumberish>,
      currency: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[boolean, boolean] & { canIssue: boolean; anyRateIsInvalid: boolean }>;

    getBorrowRate(
      overrides?: CallOverrides
    ): Promise<[BigNumber, boolean] & { borrowRate: BigNumber; anyRateIsInvalid: boolean }>;

    getNewLoanId(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    getRatesAndTime(
      index: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber] & {
        entryRate: BigNumber;
        lastRate: BigNumber;
        lastUpdated: BigNumber;
        newIndex: BigNumber;
      }
    >;

    getShortRate(
      synth: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[BigNumber, boolean] & { shortRate: BigNumber; rateIsInvalid: boolean }>;

    getShortRatesAndTime(
      currency: PromiseOrValue<BytesLike>,
      index: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber] & {
        entryRate: BigNumber;
        lastRate: BigNumber;
        lastUpdated: BigNumber;
        newIndex: BigNumber;
      }
    >;

    hasAllCollaterals(
      collaterals: PromiseOrValue<string>[],
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    hasCollateral(
      collateral: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    incrementLongs(
      synth: PromiseOrValue<BytesLike>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    incrementShorts(
      synth: PromiseOrValue<BytesLike>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    isResolverCached(overrides?: CallOverrides): Promise<[boolean]>;

    isSynthManaged(
      currencyKey: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    lastPauseTime(overrides?: CallOverrides): Promise<[BigNumber]>;

    long(
      synth: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { amount: BigNumber }>;

    maxDebt(overrides?: CallOverrides): Promise<[BigNumber]>;

    nominateNewOwner(
      _owner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    nominatedOwner(overrides?: CallOverrides): Promise<[string]>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    paused(overrides?: CallOverrides): Promise<[boolean]>;

    rebuildCache(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    removeCollaterals(
      collaterals: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    removeShortableSynths(
      synths: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    removeSynths(
      synths: PromiseOrValue<BytesLike>[],
      synthKeys: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    resolver(overrides?: CallOverrides): Promise<[string]>;

    resolverAddressesRequired(
      overrides?: CallOverrides
    ): Promise<[string[]] & { addresses: string[] }>;

    setBaseBorrowRate(
      _baseBorrowRate: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setBaseShortRate(
      _baseShortRate: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setMaxDebt(
      _maxDebt: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setPaused(
      _paused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setUtilisationMultiplier(
      _utilisationMultiplier: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    short(
      synth: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { amount: BigNumber }>;

    state(overrides?: CallOverrides): Promise<[string]>;

    synthToInverseSynth(
      arg0: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    synthsByKey(arg0: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[string]>;

    totalLong(
      overrides?: CallOverrides
    ): Promise<[BigNumber, boolean] & { susdValue: BigNumber; anyRateIsInvalid: boolean }>;

    totalShort(
      overrides?: CallOverrides
    ): Promise<[BigNumber, boolean] & { susdValue: BigNumber; anyRateIsInvalid: boolean }>;

    updateBorrowRates(
      rate: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    updateShortRates(
      currency: PromiseOrValue<BytesLike>,
      rate: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    utilisationMultiplier(overrides?: CallOverrides): Promise<[BigNumber]>;
  };

  CONTRACT_NAME(overrides?: CallOverrides): Promise<string>;

  acceptOwnership(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  addCollaterals(
    collaterals: PromiseOrValue<string>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  addShortableSynths(
    requiredSynthAndInverseNamesInResolver: [
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>
    ][],
    synthKeys: PromiseOrValue<BytesLike>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  addSynths(
    synthNamesInResolver: PromiseOrValue<BytesLike>[],
    synthKeys: PromiseOrValue<BytesLike>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  areShortableSynthsSet(
    requiredSynthNamesInResolver: PromiseOrValue<BytesLike>[],
    synthKeys: PromiseOrValue<BytesLike>[],
    overrides?: CallOverrides
  ): Promise<boolean>;

  areSynthsAndCurrenciesSet(
    requiredSynthNamesInResolver: PromiseOrValue<BytesLike>[],
    synthKeys: PromiseOrValue<BytesLike>[],
    overrides?: CallOverrides
  ): Promise<boolean>;

  baseBorrowRate(overrides?: CallOverrides): Promise<BigNumber>;

  baseShortRate(overrides?: CallOverrides): Promise<BigNumber>;

  decrementLongs(
    synth: PromiseOrValue<BytesLike>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  decrementShorts(
    synth: PromiseOrValue<BytesLike>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  exceedsDebtLimit(
    amount: PromiseOrValue<BigNumberish>,
    currency: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<[boolean, boolean] & { canIssue: boolean; anyRateIsInvalid: boolean }>;

  getBorrowRate(
    overrides?: CallOverrides
  ): Promise<[BigNumber, boolean] & { borrowRate: BigNumber; anyRateIsInvalid: boolean }>;

  getNewLoanId(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  getRatesAndTime(
    index: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, BigNumber, BigNumber] & {
      entryRate: BigNumber;
      lastRate: BigNumber;
      lastUpdated: BigNumber;
      newIndex: BigNumber;
    }
  >;

  getShortRate(
    synth: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<[BigNumber, boolean] & { shortRate: BigNumber; rateIsInvalid: boolean }>;

  getShortRatesAndTime(
    currency: PromiseOrValue<BytesLike>,
    index: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, BigNumber, BigNumber] & {
      entryRate: BigNumber;
      lastRate: BigNumber;
      lastUpdated: BigNumber;
      newIndex: BigNumber;
    }
  >;

  hasAllCollaterals(
    collaterals: PromiseOrValue<string>[],
    overrides?: CallOverrides
  ): Promise<boolean>;

  hasCollateral(collateral: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

  incrementLongs(
    synth: PromiseOrValue<BytesLike>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  incrementShorts(
    synth: PromiseOrValue<BytesLike>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  isResolverCached(overrides?: CallOverrides): Promise<boolean>;

  isSynthManaged(
    currencyKey: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  lastPauseTime(overrides?: CallOverrides): Promise<BigNumber>;

  long(synth: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber>;

  maxDebt(overrides?: CallOverrides): Promise<BigNumber>;

  nominateNewOwner(
    _owner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  nominatedOwner(overrides?: CallOverrides): Promise<string>;

  owner(overrides?: CallOverrides): Promise<string>;

  paused(overrides?: CallOverrides): Promise<boolean>;

  rebuildCache(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  removeCollaterals(
    collaterals: PromiseOrValue<string>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  removeShortableSynths(
    synths: PromiseOrValue<BytesLike>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  removeSynths(
    synths: PromiseOrValue<BytesLike>[],
    synthKeys: PromiseOrValue<BytesLike>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  resolver(overrides?: CallOverrides): Promise<string>;

  resolverAddressesRequired(overrides?: CallOverrides): Promise<string[]>;

  setBaseBorrowRate(
    _baseBorrowRate: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setBaseShortRate(
    _baseShortRate: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setMaxDebt(
    _maxDebt: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setPaused(
    _paused: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setUtilisationMultiplier(
    _utilisationMultiplier: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  short(synth: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber>;

  state(overrides?: CallOverrides): Promise<string>;

  synthToInverseSynth(arg0: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;

  synthsByKey(arg0: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;

  totalLong(
    overrides?: CallOverrides
  ): Promise<[BigNumber, boolean] & { susdValue: BigNumber; anyRateIsInvalid: boolean }>;

  totalShort(
    overrides?: CallOverrides
  ): Promise<[BigNumber, boolean] & { susdValue: BigNumber; anyRateIsInvalid: boolean }>;

  updateBorrowRates(
    rate: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  updateShortRates(
    currency: PromiseOrValue<BytesLike>,
    rate: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  utilisationMultiplier(overrides?: CallOverrides): Promise<BigNumber>;

  callStatic: {
    CONTRACT_NAME(overrides?: CallOverrides): Promise<string>;

    acceptOwnership(overrides?: CallOverrides): Promise<void>;

    addCollaterals(collaterals: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<void>;

    addShortableSynths(
      requiredSynthAndInverseNamesInResolver: [
        PromiseOrValue<BytesLike>,
        PromiseOrValue<BytesLike>
      ][],
      synthKeys: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides
    ): Promise<void>;

    addSynths(
      synthNamesInResolver: PromiseOrValue<BytesLike>[],
      synthKeys: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides
    ): Promise<void>;

    areShortableSynthsSet(
      requiredSynthNamesInResolver: PromiseOrValue<BytesLike>[],
      synthKeys: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides
    ): Promise<boolean>;

    areSynthsAndCurrenciesSet(
      requiredSynthNamesInResolver: PromiseOrValue<BytesLike>[],
      synthKeys: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides
    ): Promise<boolean>;

    baseBorrowRate(overrides?: CallOverrides): Promise<BigNumber>;

    baseShortRate(overrides?: CallOverrides): Promise<BigNumber>;

    decrementLongs(
      synth: PromiseOrValue<BytesLike>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    decrementShorts(
      synth: PromiseOrValue<BytesLike>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    exceedsDebtLimit(
      amount: PromiseOrValue<BigNumberish>,
      currency: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[boolean, boolean] & { canIssue: boolean; anyRateIsInvalid: boolean }>;

    getBorrowRate(
      overrides?: CallOverrides
    ): Promise<[BigNumber, boolean] & { borrowRate: BigNumber; anyRateIsInvalid: boolean }>;

    getNewLoanId(overrides?: CallOverrides): Promise<BigNumber>;

    getRatesAndTime(
      index: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber] & {
        entryRate: BigNumber;
        lastRate: BigNumber;
        lastUpdated: BigNumber;
        newIndex: BigNumber;
      }
    >;

    getShortRate(
      synth: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[BigNumber, boolean] & { shortRate: BigNumber; rateIsInvalid: boolean }>;

    getShortRatesAndTime(
      currency: PromiseOrValue<BytesLike>,
      index: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber] & {
        entryRate: BigNumber;
        lastRate: BigNumber;
        lastUpdated: BigNumber;
        newIndex: BigNumber;
      }
    >;

    hasAllCollaterals(
      collaterals: PromiseOrValue<string>[],
      overrides?: CallOverrides
    ): Promise<boolean>;

    hasCollateral(collateral: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

    incrementLongs(
      synth: PromiseOrValue<BytesLike>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    incrementShorts(
      synth: PromiseOrValue<BytesLike>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    isResolverCached(overrides?: CallOverrides): Promise<boolean>;

    isSynthManaged(
      currencyKey: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    lastPauseTime(overrides?: CallOverrides): Promise<BigNumber>;

    long(synth: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber>;

    maxDebt(overrides?: CallOverrides): Promise<BigNumber>;

    nominateNewOwner(_owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    nominatedOwner(overrides?: CallOverrides): Promise<string>;

    owner(overrides?: CallOverrides): Promise<string>;

    paused(overrides?: CallOverrides): Promise<boolean>;

    rebuildCache(overrides?: CallOverrides): Promise<void>;

    removeCollaterals(
      collaterals: PromiseOrValue<string>[],
      overrides?: CallOverrides
    ): Promise<void>;

    removeShortableSynths(
      synths: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides
    ): Promise<void>;

    removeSynths(
      synths: PromiseOrValue<BytesLike>[],
      synthKeys: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides
    ): Promise<void>;

    resolver(overrides?: CallOverrides): Promise<string>;

    resolverAddressesRequired(overrides?: CallOverrides): Promise<string[]>;

    setBaseBorrowRate(
      _baseBorrowRate: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setBaseShortRate(
      _baseShortRate: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setMaxDebt(_maxDebt: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    setPaused(_paused: PromiseOrValue<boolean>, overrides?: CallOverrides): Promise<void>;

    setUtilisationMultiplier(
      _utilisationMultiplier: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    short(synth: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber>;

    state(overrides?: CallOverrides): Promise<string>;

    synthToInverseSynth(
      arg0: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<string>;

    synthsByKey(arg0: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;

    totalLong(
      overrides?: CallOverrides
    ): Promise<[BigNumber, boolean] & { susdValue: BigNumber; anyRateIsInvalid: boolean }>;

    totalShort(
      overrides?: CallOverrides
    ): Promise<[BigNumber, boolean] & { susdValue: BigNumber; anyRateIsInvalid: boolean }>;

    updateBorrowRates(rate: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    updateShortRates(
      currency: PromiseOrValue<BytesLike>,
      rate: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    utilisationMultiplier(overrides?: CallOverrides): Promise<BigNumber>;
  };

  filters: {
    'BaseBorrowRateUpdated(uint256)'(baseBorrowRate?: null): BaseBorrowRateUpdatedEventFilter;
    BaseBorrowRateUpdated(baseBorrowRate?: null): BaseBorrowRateUpdatedEventFilter;

    'BaseShortRateUpdated(uint256)'(baseShortRate?: null): BaseShortRateUpdatedEventFilter;
    BaseShortRateUpdated(baseShortRate?: null): BaseShortRateUpdatedEventFilter;

    'CacheUpdated(bytes32,address)'(name?: null, destination?: null): CacheUpdatedEventFilter;
    CacheUpdated(name?: null, destination?: null): CacheUpdatedEventFilter;

    'CollateralAdded(address)'(collateral?: null): CollateralAddedEventFilter;
    CollateralAdded(collateral?: null): CollateralAddedEventFilter;

    'CollateralRemoved(address)'(collateral?: null): CollateralRemovedEventFilter;
    CollateralRemoved(collateral?: null): CollateralRemovedEventFilter;

    'LiquidationPenaltyUpdated(uint256)'(
      liquidationPenalty?: null
    ): LiquidationPenaltyUpdatedEventFilter;
    LiquidationPenaltyUpdated(liquidationPenalty?: null): LiquidationPenaltyUpdatedEventFilter;

    'MaxDebtUpdated(uint256)'(maxDebt?: null): MaxDebtUpdatedEventFilter;
    MaxDebtUpdated(maxDebt?: null): MaxDebtUpdatedEventFilter;

    'OwnerChanged(address,address)'(oldOwner?: null, newOwner?: null): OwnerChangedEventFilter;
    OwnerChanged(oldOwner?: null, newOwner?: null): OwnerChangedEventFilter;

    'OwnerNominated(address)'(newOwner?: null): OwnerNominatedEventFilter;
    OwnerNominated(newOwner?: null): OwnerNominatedEventFilter;

    'PauseChanged(bool)'(isPaused?: null): PauseChangedEventFilter;
    PauseChanged(isPaused?: null): PauseChangedEventFilter;

    'ShortableSynthAdded(bytes32)'(synth?: null): ShortableSynthAddedEventFilter;
    ShortableSynthAdded(synth?: null): ShortableSynthAddedEventFilter;

    'ShortableSynthRemoved(bytes32)'(synth?: null): ShortableSynthRemovedEventFilter;
    ShortableSynthRemoved(synth?: null): ShortableSynthRemovedEventFilter;

    'SynthAdded(bytes32)'(synth?: null): SynthAddedEventFilter;
    SynthAdded(synth?: null): SynthAddedEventFilter;

    'SynthRemoved(bytes32)'(synth?: null): SynthRemovedEventFilter;
    SynthRemoved(synth?: null): SynthRemovedEventFilter;
  };

  estimateGas: {
    CONTRACT_NAME(overrides?: CallOverrides): Promise<BigNumber>;

    acceptOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    addCollaterals(
      collaterals: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    addShortableSynths(
      requiredSynthAndInverseNamesInResolver: [
        PromiseOrValue<BytesLike>,
        PromiseOrValue<BytesLike>
      ][],
      synthKeys: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    addSynths(
      synthNamesInResolver: PromiseOrValue<BytesLike>[],
      synthKeys: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    areShortableSynthsSet(
      requiredSynthNamesInResolver: PromiseOrValue<BytesLike>[],
      synthKeys: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    areSynthsAndCurrenciesSet(
      requiredSynthNamesInResolver: PromiseOrValue<BytesLike>[],
      synthKeys: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    baseBorrowRate(overrides?: CallOverrides): Promise<BigNumber>;

    baseShortRate(overrides?: CallOverrides): Promise<BigNumber>;

    decrementLongs(
      synth: PromiseOrValue<BytesLike>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    decrementShorts(
      synth: PromiseOrValue<BytesLike>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    exceedsDebtLimit(
      amount: PromiseOrValue<BigNumberish>,
      currency: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getBorrowRate(overrides?: CallOverrides): Promise<BigNumber>;

    getNewLoanId(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    getRatesAndTime(
      index: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getShortRate(synth: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber>;

    getShortRatesAndTime(
      currency: PromiseOrValue<BytesLike>,
      index: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    hasAllCollaterals(
      collaterals: PromiseOrValue<string>[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    hasCollateral(
      collateral: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    incrementLongs(
      synth: PromiseOrValue<BytesLike>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    incrementShorts(
      synth: PromiseOrValue<BytesLike>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    isResolverCached(overrides?: CallOverrides): Promise<BigNumber>;

    isSynthManaged(
      currencyKey: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    lastPauseTime(overrides?: CallOverrides): Promise<BigNumber>;

    long(synth: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber>;

    maxDebt(overrides?: CallOverrides): Promise<BigNumber>;

    nominateNewOwner(
      _owner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    nominatedOwner(overrides?: CallOverrides): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    paused(overrides?: CallOverrides): Promise<BigNumber>;

    rebuildCache(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    removeCollaterals(
      collaterals: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    removeShortableSynths(
      synths: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    removeSynths(
      synths: PromiseOrValue<BytesLike>[],
      synthKeys: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    resolver(overrides?: CallOverrides): Promise<BigNumber>;

    resolverAddressesRequired(overrides?: CallOverrides): Promise<BigNumber>;

    setBaseBorrowRate(
      _baseBorrowRate: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setBaseShortRate(
      _baseShortRate: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setMaxDebt(
      _maxDebt: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setPaused(
      _paused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setUtilisationMultiplier(
      _utilisationMultiplier: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    short(synth: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber>;

    state(overrides?: CallOverrides): Promise<BigNumber>;

    synthToInverseSynth(
      arg0: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    synthsByKey(arg0: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber>;

    totalLong(overrides?: CallOverrides): Promise<BigNumber>;

    totalShort(overrides?: CallOverrides): Promise<BigNumber>;

    updateBorrowRates(
      rate: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    updateShortRates(
      currency: PromiseOrValue<BytesLike>,
      rate: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    utilisationMultiplier(overrides?: CallOverrides): Promise<BigNumber>;
  };

  populateTransaction: {
    CONTRACT_NAME(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    acceptOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    addCollaterals(
      collaterals: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    addShortableSynths(
      requiredSynthAndInverseNamesInResolver: [
        PromiseOrValue<BytesLike>,
        PromiseOrValue<BytesLike>
      ][],
      synthKeys: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    addSynths(
      synthNamesInResolver: PromiseOrValue<BytesLike>[],
      synthKeys: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    areShortableSynthsSet(
      requiredSynthNamesInResolver: PromiseOrValue<BytesLike>[],
      synthKeys: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    areSynthsAndCurrenciesSet(
      requiredSynthNamesInResolver: PromiseOrValue<BytesLike>[],
      synthKeys: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    baseBorrowRate(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    baseShortRate(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    decrementLongs(
      synth: PromiseOrValue<BytesLike>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    decrementShorts(
      synth: PromiseOrValue<BytesLike>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    exceedsDebtLimit(
      amount: PromiseOrValue<BigNumberish>,
      currency: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getBorrowRate(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getNewLoanId(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    getRatesAndTime(
      index: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getShortRate(
      synth: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getShortRatesAndTime(
      currency: PromiseOrValue<BytesLike>,
      index: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    hasAllCollaterals(
      collaterals: PromiseOrValue<string>[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    hasCollateral(
      collateral: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    incrementLongs(
      synth: PromiseOrValue<BytesLike>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    incrementShorts(
      synth: PromiseOrValue<BytesLike>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    isResolverCached(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    isSynthManaged(
      currencyKey: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    lastPauseTime(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    long(
      synth: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    maxDebt(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    nominateNewOwner(
      _owner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    nominatedOwner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    paused(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    rebuildCache(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    removeCollaterals(
      collaterals: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    removeShortableSynths(
      synths: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    removeSynths(
      synths: PromiseOrValue<BytesLike>[],
      synthKeys: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    resolver(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    resolverAddressesRequired(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    setBaseBorrowRate(
      _baseBorrowRate: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setBaseShortRate(
      _baseShortRate: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setMaxDebt(
      _maxDebt: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setPaused(
      _paused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setUtilisationMultiplier(
      _utilisationMultiplier: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    short(
      synth: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    state(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    synthToInverseSynth(
      arg0: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    synthsByKey(
      arg0: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    totalLong(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    totalShort(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    updateBorrowRates(
      rate: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    updateShortRates(
      currency: PromiseOrValue<BytesLike>,
      rate: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    utilisationMultiplier(overrides?: CallOverrides): Promise<PopulatedTransaction>;
  };
}
